package Mario;

import java.util.ArrayList;

import javafx.animation.Animation;
import javafx.animation.Animation.Status;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.paint.ImagePattern;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

public class Game	{
	
	private int _colsDeleted;
	private int _pulsateCount = 1;
	private boolean _paused;
	private Mario _mario;
	private Square[][] _squaresOnScreen;
	private Square[][] _squaresOffScreen;
	private Type[][] _map;
	private Type[][] _offScreenMap;
	private ArrayList<Enemy> _enemies;
	private ArrayList<Item> _items;
	private ArrayList<Offensives> _offensives;
	private ArrayList<Pulsating> _pulsating;
	private ArrayList<Character> _uninteractive;
	private Timeline _pulsate;
	private Pane _gamespace;
	private Rectangle _sky;
	private boolean _slowFall;
	
	public Game(Pane gamespace, Rectangle bg, Pane visualize)	{
		_gamespace = gamespace;
		_sky = bg;
		_gamespace.addEventHandler(KeyEvent.KEY_PRESSED, new PressHandler());
		_gamespace.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>()	{
			@Override
			public void handle(KeyEvent event) {
				if (!_paused && !_mario.isDead())	{
					KeyCode keyPressed = event.getCode();
					switch (keyPressed)	{
					case LEFT:
						_mario.getMoveTL().stop();
						_mario.getAnimate().stop();
						if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
							_mario.startingSprite();
						}
						
//						_mario.getBody().setFill(Color.RED);
						break;
					case RIGHT:
						_mario.getMoveTL().stop();
						_mario.getAnimate().stop();
						if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
							_mario.startingSprite();
						}
						
//						_mario.getBody().setFill(Color.RED);
						break;
					case SPACE:
						double minHoldY = (Constants.BLOCKS_HIGH-5)*Constants.BLOCK_LENGTH;
						if (_mario.getVelocity() < 0)	{
							if (_mario.getBody().getY() > minHoldY) {
								_mario.setVelocity(
										-1*Math.pow(2*Constants.GRAVITY*(_mario.getBody().getY() - minHoldY), 0.5));	//kinematics equation
							}
							else	{
								_mario.setVelocity(0);
							}
						}
						break;
					default:
						break;
					}
				}
			}
		});
		this.setupGame();
	}
	
	private void setupGame()	{
		_mario = new Mario(_gamespace, 0, Constants.BLOCK_LENGTH*(Constants.BLOCKS_HIGH-3));
		this.setupTLs();
		this.setupMap();
		_mario.getBody().toFront();
	}
	
	private void setupMap()	{ //make a new generation system where only blocks on screen are loaded
		Map temp = new Map();
		_enemies = new ArrayList<Enemy>();	//list of enemies on screen
		_items = new ArrayList<Item>();	//items on screen
		_offensives = new ArrayList<Offensives>();	//mario's attacks, e.g. fireballs
		_pulsating = new ArrayList<Pulsating>();	//things that pulsate on screen
		_uninteractive = new ArrayList<Character>();	//characters that the user doesn't interact with
		_squaresOnScreen = new Square[Constants.BLOCKS_HIGH][Constants.BLOCKS_WIDE];
		_squaresOffScreen = new Square[Constants.BLOCKS_HIGH][Constants.OFFSET];
		_map = temp.getMap();
		_offScreenMap = temp.getOffScreen();
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {	//generates the blocks initially on screen
			for (int j = 0 ; j < Constants.BLOCKS_WIDE; j++)	{ 
				_squaresOnScreen[i][j] = this.detNewPiece(i, j);
			}
		}
		Square piece = null;
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {	//generates the blocks initially off screen
			for (int j = 0 ; j < Constants.OFFSET; j++)	{	//offset is how many columns are off screen
				switch (_offScreenMap[i][j])	{
				case FREE:
					piece = new Square(_gamespace, Constants.BLOCK_LENGTH*(j - Constants.OFFSET), Constants.BLOCK_LENGTH*i);
					break;
				case FLOOR:
					piece = new Floor(_gamespace, Constants.BLOCK_LENGTH*(j - Constants.OFFSET), Constants.BLOCK_LENGTH*i);
					break;
				default:
					break;
				}
				_squaresOffScreen[i][j] = piece;
			}
		}
		_sky.toBack();
	}
	
	private Square detNewPiece(int i, int j)	{
		Square piece = null;
		Mystery mystery = null;
		double x = Constants.BLOCK_LENGTH*j;
		double y = Constants.BLOCK_LENGTH*i;
		switch (_map[i][j + _colsDeleted])	{
		case PIT:
		case FREE:
			piece = new Square(_gamespace, x, y);
			break;
		case BIGHILL:
			piece = new BackgroundNugget(_gamespace, x, y, Constants.BLOCK_LENGTH*5, Constants.BLOCK_LENGTH*2,
					Constants.BIG_HILL, Type.BIGHILL);
			break;
		case SMALLHILL:
			piece = new BackgroundNugget(_gamespace, x, y, Constants.BLOCK_LENGTH*3, Constants.BLOCK_LENGTH,
					Constants.SMALL_HILL, Type.SMALLHILL);
			break;
		case BIGBUSH:
			piece = new BackgroundNugget(_gamespace, x, y, Constants.BLOCK_LENGTH*5, Constants.BLOCK_LENGTH,
					Constants.BIG_BUSH, Type.BIGBUSH);
			break;
		case MEDBUSH:
			piece = new BackgroundNugget(_gamespace, x, y, Constants.BLOCK_LENGTH*4, Constants.BLOCK_LENGTH,
					Constants.MED_BUSH, Type.MEDBUSH);
			break;
		case SMALLBUSH:
			piece = new BackgroundNugget(_gamespace, x, y, Constants.BLOCK_LENGTH*3, Constants.BLOCK_LENGTH,
					Constants.SMALL_BUSH, Type.SMALLBUSH);
			break;
		case GOOMBA_START:
			piece = new Square(_gamespace, x, y);
			Goomba goomba = new Goomba(_gamespace, x, y);
			this.addNPCKeyFrame(goomba);
			goomba.getMoveTL().play();
			_enemies.add(goomba);
			break;
		case KOOPA_START:
			piece = new Square(_gamespace, x, y);
			Koopa koopa = new Koopa(_gamespace, x, y);
			this.addNPCKeyFrame(koopa);
			koopa.getMoveTL().play();
			_enemies.add(koopa);
			break;
		case FLOOR:
			piece = new Floor(_gamespace, x, y);
			break;
		case BRICK:
			piece = new Brick(_gamespace, x, y);
			break;
		case PIPE_TL:
			piece = new Pipe(_gamespace, x, y, Type.PIPE_TL);
			break;
		case PIPE_TR:
			piece = new Pipe(_gamespace, x, y, Type.PIPE_TR);
			break;
		case PIPE_L:
			piece = new Pipe(_gamespace, x, y, Type.PIPE_L);
			break;
		case PIPE_R:
			piece = new Pipe(_gamespace, x, y, Type.PIPE_R);
			break;
		case STAIR:
			piece = new Stair(_gamespace, x, y);
			break;
		case COIN_MYSTERY:
			piece = new Mystery(_gamespace, x, y, Type.COIN);
			mystery = (Mystery) piece;
			mystery.pulsate(_pulsateCount);
			_pulsating.add(mystery);
			break;
		case MUSHROOM_MYSTERY:
			piece = new Mystery(_gamespace, x, y, Type.MUSHROOM);
			mystery = (Mystery) piece;
			mystery.pulsate(_pulsateCount);
			_pulsating.add(mystery);
			break;
		case FLOWER_MYSTERY:
			piece = new Mystery(_gamespace, x, y, Type.FLOWER);
			mystery = (Mystery) piece;
			mystery.pulsate(_pulsateCount);
			_pulsating.add(mystery);
			break;
		case STAR_MYSTERY:
			piece = new Mystery(_gamespace, x, y, Type.STAR);
			mystery = (Mystery) piece;
			mystery.pulsate(_pulsateCount);
			_pulsating.add(mystery);
			break;
		default:
			break;
		}
		return piece;
	}
	
	private void addNPCKeyFrame(Character npc)	{
		KeyFrame jump = new KeyFrame(Duration.seconds(Constants.DURATION), new NPCJump(npc));
		npc.getJumpTL().getKeyFrames().add(jump);
		
		KeyFrame move = new KeyFrame(Duration.seconds(Constants.DURATION), new NPCMove(npc));
		npc.getMoveTL().getKeyFrames().add(move);
	}

	private void setupTLs()	{
		_mario.getJumpTL().getKeyFrames().add(new KeyFrame(Duration.seconds(Constants.DURATION), new MVM()));
		_mario.getMoveTL().getKeyFrames().add(new KeyFrame(Duration.seconds(Constants.DURATION/4/*5*/), new MHM()));
		_mario.getChangeForm().getKeyFrames().add(new KeyFrame(Duration.seconds(0.2), "FormChange", new ChangeForm()));
		_mario.getBlink().getKeyFrames().add(new KeyFrame(Duration.seconds(0.2), "Blink", new Blink()));

		_mario.getChangeForm().setOnFinished(new EventHandler<ActionEvent>(){
			@Override
	        public void handle(ActionEvent e) {
				_mario.setCostumes(_mario.getNewSet());
				_mario.setJumpSprite(_mario.getNewJump());
				if (_mario.getJumpTL().getStatus() == Status.PAUSED) {
					_mario.getBody().setFill(_mario.getJumpSprite());
				}
				else	{
					_mario.getBody().setFill(_mario.getSet()[0]);
				}
				if (!_mario.isBig() || _mario.isFirey())	{
					_mario.setBig(true);
				}
				else	{
					_mario.setBig(false);
				}
				if (!_mario.isBig())	{
					_mario.getBlink().play();
					_mario.setBlinking(true);
				}
				playAll();
//				_mario.getAnimate().stop();	//except animate ofc
				e.consume();
	        }
		});
		_mario.getBlink().setOnFinished(new EventHandler<ActionEvent>(){
			@Override
	        public void handle(ActionEvent e) {
				_mario.setBlinking(false);
				if (_mario.getJumpTL().getStatus() == Status.STOPPED) {
					_mario.getBody().setFill(Constants.MARIO1);
				}
				else	{
					_mario.getBody().setFill(Constants.JUMP);
				}
				playAll();
				e.consume();
	        }
		});
		
		_pulsate = new Timeline();
		_pulsate.getKeyFrames().add(new KeyFrame(Duration.seconds(0.4), new Pulsate()));
		_pulsate.setCycleCount(Animation.INDEFINITE);
		_pulsate.play();
	}
	
	public void pauseAll()	{
		_mario.pauseAll();
		for (Enemy enemy : _enemies) {
			enemy.pauseAll();
		}
		for (Item item : _items) {
			item.pauseAll();
		}
		for (Offensives attack : _offensives) {
			attack.pauseAll();
		}
		for (Character character : _uninteractive) {
			character.pauseAll();
		}
		_paused = true;
	}
	
	public void playAll()	{
		_mario.playAll();
		for (Enemy enemy : _enemies) {
			enemy.playAll();
		}
		for (Item item : _items) {
			item.playAll();
		}
		for (Offensives attack : _offensives) {
			attack.playAll();
		}
		for (Character character : _uninteractive) {
			character.playAll();
		}
		_paused = false;
	}
	
	private Square nextBlock(Character character, double xDisplacement, double yDisplacement)	{
		//only works with horizontal and vertical checks
		Line collisionLine = null;
		Line collisionLine2 = null;
		ArrayList<Line> lines = new ArrayList<Line>();
		if (yDisplacement == 0)	{	//moving horizontally
			if (character.getDir() == Direction.LEFT)	{
				collisionLine = character.getCollisionLines()[0];
			}
			else if (character.getDir() == Direction.RIGHT)	{
				collisionLine = character.getCollisionLines()[1];
			}
		}
		else if (xDisplacement == 0)	{	//moving vertically
			if (character.getVelocity() >= 0 || character.getJumpTL().getStatus() == Status.STOPPED) {
				collisionLine = character.getCollisionLines()[0];
				collisionLine2 = character.getCollisionLines()[1];
			}
			else if (character.getVelocity() < 0)	{
				collisionLine = character.getCollisionLines()[2];
				collisionLine2 = character.getCollisionLines()[3];
			}
			lines.add(collisionLine2);
		}
		lines.add(collisionLine);
		
		for (Line line : lines)	{
			if (line == null)	{
				return null;
			}
			Line testLine = new Line(line.getStartX() + xDisplacement, 
					line.getStartY() + yDisplacement,
					line.getEndX() + xDisplacement,
					line.getEndY() + yDisplacement);
			for (Square[] squares : _squaresOnScreen)	{
				for (Square square : squares)	{
					if (square.getBody().intersects(testLine.getBoundsInLocal())
							&& !square.isFree()) {
						return square;
					}
				}
			}
		}
		return null;
	}

	private class PressHandler implements EventHandler<KeyEvent>	{
		
		public PressHandler()	{}
		
		@Override
		public void handle(KeyEvent event)	{
			if (!_paused && !_mario.isDead())	{
				KeyCode keyPressed = event.getCode();
				switch (keyPressed)	{
				case LEFT:
					if (_mario.getMoveTL().getStatus() != Status.RUNNING)	{
						_mario.setDir(Direction.LEFT);
						_mario.getBody().setRotate(180);
						_mario.getMoveTL().play();
						if (_mario.getAnimate().getStatus() != Status.RUNNING)	{
							_mario.switchCostume();
							_mario.getAnimate().play();
						}
					}
					break;
				case RIGHT:
					if (_mario.getMoveTL().getStatus() != Status.RUNNING)	{
						_mario.setDir(Direction.RIGHT);
						_mario.getBody().setRotate(0);
						_mario.getMoveTL().play();
						if (_mario.getAnimate().getStatus() != Status.RUNNING)	{
							_mario.switchCostume();
							_mario.getAnimate().play();
						}
					}
					break;
				case SPACE:
					if (_mario.getJumpTL().getStatus() == Status.STOPPED/*RUNNING*/) {
						_mario.getBody().setFill(_mario.getJumpSprite());
						_mario.getAnimate().pause();
						_mario.setVelocity(_mario.getInitV());
						_mario.getJumpTL().play();
					}
//					if (_mario.getVelocity() < 0 /*-600*/
//							&& _mario.getVelocity() > Constants.INIT_V*5/6) {
//						_mario.setVelocity(0);
//					}
					break;
				case DOWN:
					break;
				case U:
					_mario.setSpeedWeight(2);
					break;
				case D:
					_mario.setSpeedWeight(1);
					break;
				case K:
					_mario.transform();
					break;
				case X:
					System.out.println(_mario.getBody().getX());
					break;
				case Y:
					System.out.println(_mario.getBody().getY());
					break;
				case S:
					_mario.getJumpTL().getKeyFrames().clear();
					if (_slowFall)	{
						_slowFall = false;
						_mario.getJumpTL().getKeyFrames().add(new KeyFrame(Duration.seconds(Constants.DURATION), new MVM()));
					}
					else	{
						_slowFall = true;
						_mario.getJumpTL().getKeyFrames().add(new KeyFrame(Duration.seconds(Constants.DURATION*5), new MVM()));
					}
					break;
				case H:
					if (_mario.getBody().getFill() == Color.RED)	{
						_mario.getBody().setFill(Constants.MARIO1);
					}
					else	{
						_mario.getBody().setFill(Color.RED);
						_mario.getAnimate().stop();
					}
					break;
				case G:
					Mushroom shroom = new Mushroom(_gamespace, _mario.getBody().getX(),  _mario.getBody().getY() - 3*Constants.BLOCK_LENGTH, Type.MUSHROOM);
					addNPCKeyFrame(shroom);
					shroom.getMoveTL().stop();
					_items.add(shroom);
					break;
				case L:
					Flower flwr = new Flower(_gamespace, _mario.getBody().getX(),  _mario.getBody().getY() - Constants.BLOCK_LENGTH, Type.FLOWER);
					addNPCKeyFrame(flwr);
					_items.add(flwr);
					break;
				case B:
					System.out.println(_mario.isBig());
					break;
				case E:
					System.out.println(_enemies.size());
					break;
				case O:
					System.out.println(_offensives.size());
					break;
				case Q:
					Platform.exit();
					break;
				case F:
					if (_mario.isFirey()) {
						Fireball fireball = null;
						if (_mario.getDir() == Direction.RIGHT)	{
							fireball = new Fireball(_gamespace, _mario.getBody().getX() + _mario.getBody().getWidth(), _mario.getBody().getY());
						}
						else	{
							fireball = new Fireball(_gamespace, _mario.getBody().getX(), _mario.getBody().getY());
						}
						
						if (fireball != null)	{
							fireball.setInitV(Constants.INIT_V/2.5);
							fireball.setSpeedWeight(5);
							fireball.setDir(_mario.getDir());
							_offensives.add(fireball);
							addNPCKeyFrame(fireball);
							fireball.getMoveTL().play();
						}
						if (_mario.getCostNum() == 0)	{
							_mario.getBody().setFill(Constants.FIRE_MARIO_SHOOT[0]);
						}
						else	{
							_mario.getBody().setFill(Constants.FIRE_MARIO_SHOOT[_mario.getCostNum()-1]);
						}
						_mario.getReturnToStandard().play();
					}
					break;
				default:
					break;
				}
			}
			
			event.consume();
		}
	}
	//make pause and stop all the same
	
	private class MVM implements EventHandler<ActionEvent>	{

		private ArrayList<Enemy> _removeable;
		
		public MVM()	{
			_removeable = new ArrayList<Enemy>();
		}
		
		@Override
        public void handle(ActionEvent e) {
			_mario.updateVelocity();
			double displacement = _mario.getVelocity() * Constants.DURATION;
			
			if (_mario.isDead())	{
				_mario.move(0, displacement);
			}
			else if (_mario.getVelocity() > 0)	{
				this.goingDown();
			}	
			else if (_mario.getVelocity() <= 0)	{
				this.goingUp();
			}
			
			if (_mario.getBody().getY() > Constants.MAX_Y)	{
				Platform.exit();
			}
			
			_enemies.removeAll(_removeable);
			_removeable.clear();
			
			e.consume();
        }
		
		@SuppressWarnings("unlikely-arg-type")
		private void detBlockAction(Square block)	{
			if (!block.isImpacted())	{
				if (block.getType() == Type.BRICK)	{
					if (_mario.isBig() && block.getBop().getStatus() != Status.RUNNING)	{
						block.delete();
					}
					else	{
						block.getBop().play();
					}
				}
				else if (block.getType() == Type.COIN
						|| block.getType() == Type.MUSHROOM
						|| block.getType() == Type.FLOWER
						|| block.getType() == Type.STAR)	{
					this.newItem(block);
					block.delete();
					_pulsating.remove(block);
				}
				for (Enemy enemy : _enemies)	{ //kills enemies if block under them is hit
					if (block.getBody().intersects(enemy.getFoot().getBoundsInLocal())) {
						if (enemy.getType() == Type.KOOPA) {
							enemy.overTurn();
						}
						else	{
							enemy.deathAnimation();
						}
					}
				}
			}
		}
		
		private void newItem(Square block)	{
			//puts an item on the screen depending on what block was hit
			Item item = null;
			switch (block.getType())	{
			case COIN:
				_uninteractive.add(new Coin(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.COIN));
				break;
			case MUSHROOM:
				item = new Mushroom(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.MUSHROOM);
				addNPCKeyFrame(item);
				break;
			case FLOWER:
				item = new Flower(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.FLOWER);
				addNPCKeyFrame(item);
				break;
			case STAR:
				item = new Star(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.STAR);
				addNPCKeyFrame(item);
				break;
			default:
				break;
			}
			if (item!=null)	{
				_items.add(item);
			}
			_sky.toBack();
		}
		
		private void detEnemyAction(Enemy enemy)	{
			//initiates an enemy's reponse to being jumped on
			switch (enemy.getType())	{
			case GOOMBA:
				enemy.delete();
				_enemies.remove(enemy);
				_uninteractive.add((Character) enemy);
				break;
			case KOOPA:
				if (enemy.getHead().intersects(_mario.getCollisionLines()[0].getBoundsInLocal())
						&& enemy.getHead().intersects(_mario.getCollisionLines()[1].getBoundsInLocal()))	{
					enemy.setDir(Direction.NONE);
				}
				else if (enemy.getHead().intersects(_mario.getCollisionLines()[0].getBoundsInLocal()))	{
					enemy.setDir(Direction.LEFT);
				}
				else if (enemy.getHead().intersects(_mario.getCollisionLines()[1].getBoundsInLocal()))	{
					enemy.setDir(Direction.RIGHT);
				}
				else	{
					enemy.setDir(Direction.NONE);
				}
				
				enemy.rogueAction(_mario);
				
//				enemy.getBody().setFill(Color.RED);
				//if mario touches the bottom half he dies
				break;
			default:
				break;
			}
		}
		
		private void goingUp()	{
			double displacement = _mario.getVelocity() * Constants.DURATION;
			Square nextBlock = nextBlock(_mario, 0, displacement);
			if (nextBlock != null)	{
				_mario.setVelocity(_mario.getVelocity()*-1);
				this.detBlockAction(nextBlock);
			}
//			for (Enemy enemy : _enemies)	{
//				 if ((_mario.getCollisionLines()[0].intersects(enemy.getBody().getBoundsInLocal())
//							||_mario.getCollisionLines()[1].intersects(enemy.getBody().getBoundsInLocal()))
//							&& enemy.isRogue()
//							&& enemy.getMoveTL().getStatus() != Status.RUNNING
//							&& _mario.getJumpTL().getStatus() != Status.RUNNING)	{
//						enemy.move(15*Constants.DISPLACEMENT*_mario.getSpeedWeight()*_mario.getDir().direction(), 0);
//						enemy.setDir(_mario.getDir());
//						enemy.rogueAction(_mario);
//					}
//			}
			_mario.move(0,displacement);
		}
		
		private void goingDown()	{
			double displacement = _mario.getVelocity() * Constants.DURATION;
			Line foot = _mario.getFoot();
			Rectangle enemyHead = null;
			Square nextBlock = nextBlock(_mario, 0, displacement);
			if (nextBlock != null && !_mario.isDead())	{	//when it lands
				_mario.onHittingGround();
				_mario.move(0, nextBlock.getBody().getY() - _mario.getBody().getY() - _mario.getBody().getHeight()-1);
			}
			else	{ 
				_mario.move(0,displacement);
			}
			
			for (Enemy enemy : _enemies)	{	//checks to see if mario is jumping on an enemy
				enemyHead = new Rectangle(enemy.getBody().getX(), enemy.getBody().getY(), 
						enemy.getBody().getWidth(), enemy.getBody().getHeight()/2);
				if (enemyHead.intersects(foot.getBoundsInLocal())
						&& !enemy.isDead())	{
					_mario.setVelocity(_mario.getInitV());
					this.detEnemyAction(enemy);
					break;	//patch
				}
			}
		}
		
	}
	
	private class MHM implements EventHandler<ActionEvent>	{

		public MHM()	{}
	
		@Override
        public void handle(ActionEvent e) {
			
			this.determineAction();
			this.checkCollisions();
			
			e.consume();
        }
		
		private void determineAction()	{
			double displacement = _mario.getDir().direction()*Constants.DISPLACEMENT*_mario.getSpeedWeight();
			if (_mario.isDead()) {	//prioritizes falling to the bottom of the screen if dead
				_mario.move(displacement, 0);
			}
			else if (nextBlock(_mario, 0, 1) == null
					&& _mario.getJumpTL().getStatus() != Status.RUNNING)	{	//acts as a gravity simulation
				_mario.fall();
			}
			else if (nextBlock(_mario, displacement, 0) == null)	{ //if mario is moving to a free block
				if (_mario.getBody().getX() >= Constants.MAX_X
						&& _colsDeleted < Constants.TOT_BLOCKS_WIDE - Constants.BLOCKS_WIDE) {	//if mario is at scrolling distance and the end of the level is not reached
					this.adjustSquares();
					this.checkScroll();
					_sky.toBack();
				}
				_mario.move(displacement,0);
			}
		}
		
		private void checkCollisions()	{
			Rectangle deathZone = null;
			for (Enemy enemy : _enemies)	{
				deathZone = new Rectangle(enemy.getCollisionLines()[0].getStartX(), 
						enemy.getCollisionLines()[0].getStartY(), 
						enemy.getBody().getWidth(),
						enemy.getBody().getHeight()/2);
				if ((_mario.getCollisionLines()[0].intersects(deathZone.getBoundsInLocal())
						||_mario.getCollisionLines()[1].intersects(deathZone.getBoundsInLocal()))
						&& !_mario.isBlinking() && !enemy.isDead()
						&& _mario.getJumpTL().getStatus() != Status.RUNNING
						&& enemy.getMoveTL().getStatus() == Status.RUNNING)	{
					pauseAll();
					_mario.die();
				}
				else if ((_mario.getCollisionLines()[0].intersects(deathZone.getBoundsInLocal())
						||_mario.getCollisionLines()[1].intersects(deathZone.getBoundsInLocal()))
						&& enemy.isRogue()
						&& enemy.getMoveTL().getStatus() != Status.RUNNING
						&& _mario.getVelocity() < 0)	{	//weird bug when jumping on a turtle and moving where it just starts goin
					enemy.move(15*Constants.DISPLACEMENT*_mario.getSpeedWeight()*_mario.getDir().direction(), 0);
					enemy.setDir(_mario.getDir());
					enemy.rogueAction(_mario);
				}
			}
			for (Line line : _mario.getCollisionLines())	{
				for (Item item : _items)	{
					if (line.intersects(item.getBody().getBoundsInLocal()))	{
						this.initEffect(item);
						_items.remove(item);
						break;
					}
				}
			}
		}
		
		private void initEffect(Item item)	{
			switch (item.getType())	{
			case MUSHROOM:
				if (!_mario.isBig())	{
					pauseAll();
					_mario.growOrShrink();
				}
				break;
			case FLOWER:
				if (!_mario.isFirey())	{
					pauseAll();
					_mario.transform();
				}
				break;
			case STAR:
				_mario.invincible();
				break;
			default:
				break;
			}
			item.delete();
		}
	
		private void checkScroll()	{
			if (_squaresOnScreen[0][0].getBody().getX() <= -1 * Constants.BLOCK_LENGTH) {
				this.shiftArrays();
				_mario.getBody().toFront();
				if (_colsDeleted != Constants.TOT_BLOCKS_WIDE + Constants.BLOCKS_WIDE)	{
					_colsDeleted++;
				}
			}
		}
		
		private void shiftArrays()	{
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++)	{	//moves columns of array one space to the left
				for (int j = 1 ; j < Constants.OFFSET; j++)	{
					_squaresOffScreen[i][j-1] = _squaresOffScreen[i][j];
				}
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++)	{	//moves the leftmost column of onscreen to rightmost of offscreen
				_squaresOffScreen[i][Constants.OFFSET-1] = _squaresOnScreen[i][0];
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH; i++)	{	//moves columns of array one space to the left
				for (int j = 1 ; j < Constants.BLOCKS_WIDE; j++)	{
					_squaresOnScreen[i][j-1] = _squaresOnScreen[i][j];
				}
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {	//generate new squares, going down the column
				_squaresOnScreen[i][Constants.BLOCKS_WIDE-1] = 
						detNewPiece(i, Constants.BLOCKS_WIDE-1);
			}
			for (Enemy enemy : _enemies)	{
				enemy.getBody().toFront();
			}
			for (Offensives attack : _offensives)	{
				attack.getBody().toFront();
			}
		}
		
		private void adjustSquares()	{
			for (Square[] pieces : _squaresOffScreen)	{
				for (Square piece : pieces)	{
					piece.getBody().setX(piece.getBody().getX() - Constants.DISPLACEMENT*_mario.getSpeedWeight());
					if (piece.getBody().getX() < -1 * piece.getBody().getWidth() - Constants.OFFSET*Constants.BLOCK_LENGTH)	{
						piece.delete();
					}
				}
			}
			for (Square[] squares : _squaresOnScreen)	{
				for (Square square : squares)	{
					square.getBody().setX(square.getBody().getX() - Constants.DISPLACEMENT*_mario.getSpeedWeight());
				}
			}
			for (Enemy enemy : _enemies) {
				enemy.move(-1*Constants.DISPLACEMENT*_mario.getSpeedWeight(), 0);
				if (enemy.getBody().getX() < -1 * Constants.OFFSET*Constants.BLOCK_LENGTH)	{
					_enemies.remove(enemy);
					enemy = null;
					break;
				}
			}
			for (Offensives attack : _offensives) {
				attack.move(-1*Constants.DISPLACEMENT*_mario.getSpeedWeight(), 0);
				if (attack.getBody().getX() < -1 * Constants.OFFSET*Constants.BLOCK_LENGTH)	{
					_offensives.remove(attack);
					attack = null;
					break;
				}
			}
			ArrayList<Character> entities = new ArrayList<Character>();
			ArrayList<Character> removeable = new ArrayList<Character>();
			entities.addAll(_items);
			entities.addAll(_uninteractive);
			for (Character entity : entities) {
				entity.move(-1*Constants.DISPLACEMENT*_mario.getSpeedWeight(), 0);
				if (entity.getBody().getX() < -Constants.OFFSET*Constants.BLOCK_LENGTH)	{
					removeable.add(entity);
				}
			}
			_items.removeAll(removeable);	_uninteractive.removeAll(removeable);
		}
		}
	
	private class NPCJump implements EventHandler<ActionEvent>	{

		private Character _jumping;
		
		public NPCJump(Character jumping)	{
			_jumping = jumping;
		}
		
		@SuppressWarnings("unlikely-arg-type")
		@Override
        public void handle(ActionEvent e) {
			double displacement = _jumping.getVelocity() * Constants.DURATION;
			_jumping.updateVelocity();
			
			if (_jumping.isDead())	{
				_jumping.move(0, displacement);
			}
			else if (_jumping.getVelocity() > 0)	{
				this.goingDown();
			}	
			else if (_jumping.getVelocity() <= 0)	{
				this.goingUp();
			}
			
			if (_jumping.getBody().getY() > Constants.MAX_Y)	{
				_enemies.remove(_jumping);	_items.remove(_jumping);	_offensives.remove(_jumping);	_uninteractive.remove(_jumping);
				_gamespace.getChildren().remove(_jumping.getBody());
				_jumping.pauseAll();
			}
			
//			if (_jumping.getBody().intersects(_mario.getBody().getBoundsInLocal())
//					&& _jumping.getType() == Type.KOOPA
//					&& _jumping.isRogue()
//					&& _jumping.getMoveTL().getStatus() != Status.RUNNING)	{	//handles edge case when a koopa is in its shell and falling
//				_jumping
//			}
			
			e.consume();
        }
		
		private void goingDown()	{
			double displacement = _jumping.getVelocity() * Constants.DURATION;
			Square nextBlock = nextBlock(_jumping, 0, displacement);
			if (nextBlock != null && !_jumping.isDead())	{	//when it lands
				_jumping.onHittingGround();
				_jumping.move(0, nextBlock.getBody().getY() - _jumping.getBody().getY() - _jumping.getBody().getHeight()-1);
			}
			else	{ 
				_jumping.move(0, displacement);
			}
		}
		
		private void goingUp()	{
			double displacement = _jumping.getVelocity() * Constants.DURATION;
			if (nextBlock(_jumping, 0, displacement) != null)	{
				_jumping.setVelocity(_jumping.getVelocity()*-1);
			}
			_jumping.move(0, displacement);
		}
		
	}
	
	private class NPCMove implements EventHandler<ActionEvent>	{

		private Character _moving;
		
		public NPCMove(Character npc)	{
			_moving = npc;
		}
	
		@Override
        public void handle(ActionEvent e) {
			
			this.checkCollisions();
			this.determineAction();
			this.checkForAttacks();
			
			e.consume();
        }
		
		private void initEffect()	{
			switch (_moving.getType())	{
			case MUSHROOM:
				if (!_mario.isBig())	{
					pauseAll();
					_mario.growOrShrink();
				}
				break;
			case FLOWER:
				if (!_mario.isFirey())	{
					pauseAll();
					_mario.transform();
				}
				break;
			case STAR:
				_mario.invincible();
				break;
			default:
				break;
			}
			_moving.delete();
			_items.remove(_moving);
		}
		
		@SuppressWarnings("unlikely-arg-type")
		private boolean nextToNPC()	{
			int index = 0;
			if (_moving.getDir() == Direction.LEFT) {
				index = 0;
			}
			else if (_moving.getDir() == Direction.RIGHT) {
				index = 1;
			}
			Line sideFacing  = _moving.getCollisionLines()[index];
			for (Enemy enemy : _enemies)	{
				if (enemy.getBody().intersects(sideFacing.getBoundsInLocal())
						&& !enemy.equals(_moving))	{
					if (_moving.isRogue() && !_moving.isDead() && !enemy.isDead())	{
						enemy.deathAnimation(); 
					}
					return true;
				}
			}
			for (Item item : _items)	{
				if (item.getBody().intersects(sideFacing.getBoundsInLocal())
						&& !item.equals(_moving))	{
					return true;
				}
			}
			return false;
		}
	
		@SuppressWarnings("unlikely-arg-type")
		private void checkForAttacks()	{
			for (Enemy enemy : _enemies)	{
				if (enemy.getBody().intersects(_moving.getBody().getBoundsInLocal())
						&& _offensives.contains(_moving)
						&& !enemy.isDead())	{
					enemy.deathAnimation(); 
					_moving.delete();
					_offensives.remove(_moving);
				}
			}
		}
		
		private void checkCollisions()	{
			Rectangle deathZone = new Rectangle(_moving.getCollisionLines()[0].getStartX(), 
					_moving.getCollisionLines()[0].getStartY(), 
					_moving.getBody().getWidth(),
					_moving.getBody().getHeight()/2);
			if ((_mario.getCollisionLines()[0].intersects(deathZone.getBoundsInLocal())
					||_mario.getCollisionLines()[1].intersects(deathZone.getBoundsInLocal()))
					&& !_mario.isDead() && !_mario.isBlinking() && !_moving.isDead() && _moving.isEnemy()
					&& _moving.getMoveTL().getStatus() == Status.RUNNING)	{
				pauseAll();
				_mario.die();
			}
			for (Line line : _mario.getCollisionLines())	{
				if (_moving.getBody().intersects(line.getBoundsInLocal())
						&& _moving.isNPC() && !_moving.isEnemy())	{
					this.initEffect();
				}
			}
		}
	
		private void determineAction()	{
			double displacement = _moving.getDir().direction()*Constants.DISPLACEMENT*_moving.getSpeedWeight();
			if (_moving.isDead()) {
				_moving.move(displacement, 0);
			}
			else if (nextBlock(_moving, 0, 1) == null
					&& _moving.getJumpTL().getStatus() == Status.STOPPED)	{
				_moving.fall();
			}
			else if (nextBlock(_moving, displacement, 0) == null
					&& (!nextToNPC() || _moving.isRogue()))	{
				_moving.move(displacement, 0);
			}
			else if (!_moving.isDead())	{
				_moving.flip();
			}
		}
	}
	
	private class Pulsate implements EventHandler<ActionEvent>	{

		@Override
		public void handle(ActionEvent event) {
			if (!_pulsating.isEmpty())	{
				for (Pulsating pulsable : _pulsating)	{
					pulsable.pulsate(_pulsateCount);
				}
				if (_pulsateCount == Constants.MYSTERY_SET.length-1)	{
					_pulsateCount = 0;
				}
				else	{
					_pulsateCount++;
				}
			}
		}
		
	}
	
	private class ChangeForm implements EventHandler<ActionEvent>	{

		
		//bugs:
		//going from fire&big to small
		
		private int _count = 1;
		@Override
        public void handle(ActionEvent e) {
			ImagePattern[] set = null;
			ImagePattern jump = null;
			if (_count%2==1)	{	//look like new thing
				if ((_mario.isBig() && !_mario.isFirey()) || !_mario.isBig()) {
					_mario.changeHeight(true);
				}
				set = _mario.getNewSet();
				jump = _mario.getNewJump();
			}
			else	{	//look like old thing
				if ((_mario.isBig() && !_mario.isFirey()) || !_mario.isBig()) {
					_mario.changeHeight(false);
				}
				set = _mario.getSet();
				jump = _mario.getJumpSprite();
			}
			_mario.adjustCollisionLines();
			_mario.updateSprite(set,jump);
			
			_count++;
			
			e.consume();
        }
		
	}
	
	private class Blink implements EventHandler<ActionEvent>	{

		@Override
        public void handle(ActionEvent e) {
			if (_gamespace.getChildren().contains(_mario.getBody()))	{
				_gamespace.getChildren().remove(_mario.getBody());
			}
			else	{
				_gamespace.getChildren().add(_mario.getBody());
			}
			
			e.consume();
        }
		
	}
	
}




package Mario;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.animation.Animation.Status;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.layout.Pane;
import javafx.scene.paint.ImagePattern;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

public class Mario extends Character	{
	
	private Rectangle _body;
	private ImagePattern _jumpSprite;
	private Timeline _changeForm;
	private Timeline _blinking;
	private Timeline _goBackToStandard;
	private boolean _isBig;
	private boolean _isFirey;
	private boolean _isBlinking;
	private ImagePattern[] _newSet;
	private ImagePattern _newJump;
	
	public Mario(Pane parent, int x, int y)	{
		super(parent,x,y);
		_body = super.getBody();
		_body.setFill(Constants.MARIO1);
		_body.setRotationAxis(Rotate.Y_AXIS);
		_jumpSprite = Constants.JUMP;
		super.replaceCollisionLine(0, new Line(_body.getX() + 6, _body.getY() + _body.getHeight(), _body.getX() + 6, _body.getY() + _body.getHeight()/2));
		super.replaceCollisionLine(1, new Line(_body.getX() + _body.getWidth() - 6, _body.getY() + _body.getHeight(), _body.getX() + _body.getWidth() - 6, _body.getY() + _body.getHeight()/2));
		super.replaceCollisionLine(2, new Line(_body.getX() + 6, _body.getY() + _body.getHeight()/2, _body.getX() + 6, _body.getY()));
		super.replaceCollisionLine(3, new Line(_body.getX() + _body.getWidth() - 6, _body.getY() + _body.getHeight()/2, _body.getX() + _body.getWidth() - 6, _body.getY()));
		super.setCostumes(Constants.MARIO);
		super.setNPC(false);
		super.setType(Type.MARIO);
		super.getAnimate().stop();
	}
	
	@Override
	public void setupTLs()	{
		super.setupTLs();

		_changeForm = new Timeline();
		_changeForm.setCycleCount(7);	//must be odd
		
		_blinking = new Timeline();
		_blinking.setCycleCount(12);	//must be even
		
		_goBackToStandard = new Timeline();
		_goBackToStandard.setCycleCount(1);
		_goBackToStandard.getKeyFrames().add(new KeyFrame(Duration.seconds(0.2),
				new EventHandler<ActionEvent>()	{

					@Override
					public void handle(ActionEvent event) {
						if (getCostNum() == 0)	{
							_body.setFill(getSet()[0]);
						}
						else	{
							_body.setFill(getSet()[getCostNum()-1]);
						}
						if (getAnimate().getStatus() == Status.PAUSED)	{
							getAnimate().play();
						}
					}
			
		}));
		
	}
	
	@Override
	public void fall()	{
		super.fall();
		_body.setFill(_jumpSprite);
	}
	
	@Override
	public void onHittingGround()	{
		super.onHittingGround();
		_body.setFill(super.getSet()[0]);
	}
	
	@Override
	public void move(double xDisplacement, double yDisplacement)	{
		double newX = super.getBody().getX() + xDisplacement;
		if (newX >= Constants.MIN_X && newX <= Constants.MAX_X)	{
			super.move(xDisplacement, yDisplacement);
		}
	}
	
	public void growOrShrink()	{
		super.getAnimate().stop();
		super.getMoveTL().stop();
		if (!_isBig)	{
			_newSet = Constants.BIG_MARIO;
			_newJump = Constants.BIG_JUMP;
		}
		else	{
			_newSet = Constants.MARIO;
			_newJump = Constants.JUMP;
		}
		_blinking.stop();
		_body.setFill(super.getSet()[0]);
		_changeForm.play();
	}
	
	public void die()	{
		if (_isBig)	{
			this.growOrShrink();
			_isFirey = false;
		}
		else	{
			super.getMoveTL().stop();
			super.getJumpTL().stop();
			super.setVelocity(-200);
			super.setDead(true);
			super.getBody().setFill(Constants.DEAD);
			_body.setY(_body.getY()-_body.getY()%Constants.BLOCK_LENGTH); //uhhhhhhhhhhhhh
			super.getJumpTL().play();
		}
	}
	
	public void transform()	{
		super.getAnimate().pause();
		super.getMoveTL().stop();
		_isFirey = true;
		_newSet = Constants.FIRE_MARIO;
		_newJump = Constants.FIRE_JUMP;
		_blinking.stop();
		_body.setFill(super.getSet()[0]);
		_changeForm.play();
	}
	
	public void invincible()	{
		
	}
	
	public void adjustCollisionLines()	{
		super.replaceCollisionLine(0, new Line(_body.getX() + 6, _body.getY() + _body.getHeight(), _body.getX() + 6, _body.getY() + _body.getHeight()/2));
		super.replaceCollisionLine(1, new Line(_body.getX() + _body.getWidth() - 6, _body.getY() + _body.getHeight(), _body.getX() + _body.getWidth() - 6, _body.getY() + _body.getHeight()/2));
		super.replaceCollisionLine(2, new Line(_body.getX() + 6, _body.getY() + _body.getHeight()/2, _body.getX() + 6, _body.getY()));
		super.replaceCollisionLine(3, new Line(_body.getX() + _body.getWidth() - 6, _body.getY() + _body.getHeight()/2, _body.getX() + _body.getWidth() - 6, _body.getY()));
	}
	
	/** used for transformations*/
	public void updateSprite(ImagePattern[] set, ImagePattern jump)	{
		if (super.getJumpTL().getStatus() == Status.STOPPED)	{
			if (super.getCostNum() == 0)	{
				_body.setFill(set[0]);
			}
			else	{
				_body.setFill(set[super.getCostNum() - 1]);
			}
		}
		else	{
			_body.setFill(jump);
		}
	}
	
	public void changeHeight(boolean grow)	{
		double newY = 0;
		if (grow)	{
			_body.setHeight(2*Constants.BLOCK_LENGTH);
			newY = _body.getY() - Constants.BLOCK_LENGTH;
		}
		else	{
			_body.setHeight(Constants.BLOCK_LENGTH);
			newY = _body.getY() + Constants.BLOCK_LENGTH;
		}
		if (super.getJumpTL().getStatus() == Status.STOPPED)	{
			_body.setY(newY);
		}
	}
	
	public boolean isBlinking()	{
		return _isBlinking;
	}
	
	public boolean isBig()	{
		return _isBig;
	}
	
	public boolean isFirey()	{
		return _isFirey;
	}
	
	public Timeline getChangeForm()	{
		return _changeForm;
	}
	
	public Timeline getBlink()	{
		return _blinking;
	}
	
	public Timeline getReturnToStandard()	{
		return _goBackToStandard;
	}
	
	public ImagePattern getJumpSprite()	{
		return _jumpSprite;
	}
	
	public ImagePattern[] getNewSet()	{
		return _newSet;
	}
	
	public ImagePattern getNewJump()	{
		return _newJump;
	}
	
	public void setFirey(boolean yn)	{
		_isFirey = yn;
	}
	
	public void setBlinking(boolean yn)	{
		_isBlinking = yn;
	}
	
	public void setBig(boolean yn)	{
		_isBig = yn;
	}
	
	public void setJumpSprite(ImagePattern sprite)	{
		_jumpSprite = sprite;
	}
	
}
CHANGEFORM, cool concept poorly implemented
	private class ChangeForm implements EventHandler<ActionEvent>	{

		
		//bugs:
		//going from fire&big to small
		
		private int _count = 1;
		@Override
        public void handle(ActionEvent e) {
			ImagePattern[] set = null;
			ImagePattern jump = null;
			if (_count%2==1)	{	//look like new thing
				if ((_mario.isBig() && !_mario.isFirey()) || !_mario.isBig()) {
					_mario.changeHeight(true);
				}
				set = _mario.getNewSet();
				jump = _mario.getNewJump();
			}
			else	{	//look like old thing
				if ((_mario.isBig() && !_mario.isFirey()) || !_mario.isBig()) {
					_mario.changeHeight(false);
				}
				set = _mario.getSet();
				jump = _mario.getJumpSprite();
			}
			_mario.adjustCollisionLines();
			_mario.updateSprite(set,jump);
			
			_count++;
			
			e.consume();
        }
		
	}











private class ChangeForm implements EventHandler<ActionEvent>	{

		private int _count = 1;
		@Override
        public void handle(ActionEvent e) {
			Rectangle body = _mario.getBody();
			System.out.println(_mario.isBig());
			if (_count%2==1)	{	//look like new thing ----big mario----
				if (!_mario.isBig()) {
					System.out.println("ajfskkl;adfskl");
					body.setHeight(2*Constants.BLOCK_LENGTH);
					if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
						body.setY(body.getY() - Constants.BLOCK_LENGTH);
					}
				}
				_mario.setCostumes(Constants.BIG_MARIO);
				_mario.setJumpSprite(Constants.BIG_JUMP);
			}
			else	{	//look like old thing-----little mario
				if (!_mario.isBig()) {
					body.setHeight(Constants.BLOCK_LENGTH);
					if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
						body.setY(body.getY() + Constants.BLOCK_LENGTH);
					}
				}
				_mario.setCostumes(Constants.MARIO);
				_mario.setJumpSprite(Constants.JUMP);
			}
			_mario.adjustCollisionLines();
			_mario.updateSprite();
			
			_count++;
			
			e.consume();
        }
		
	}
	












public void transform()	{
		super.getAnimate().pause();
//		super.setCostumes(Constants.FIRE_MARIO);
//		this.setBig(true);
//		_body.setFill(Constants.FIRE_MARIO1);
//		_body.setHeight(2*Constants.BLOCK_LENGTH);
//		if (super.getJumpTL().getStatus() == Status.STOPPED)	{
//			_body.setY(_body.getY() - Constants.BLOCK_LENGTH);
//		}
//		_jumpSprite = Constants.FIRE_JUMP;
		_newSet = Constants.FIRE_MARIO;
//		_isBig = true;
		_changeForm.play();
	}




for (Enemy enemy : _enemies)	{
				deathZone = new Rectangle(enemy.getCollisionLines()[0].getStartX(), 
						enemy.getCollisionLines()[0].getStartY(), 
						enemy.getBody().getWidth(),
						enemy.getBody().getHeight()/2);
				if (marioSide.intersects(deathZone.getBoundsInLocal()) && !_mario.isDead() 
						&& !_mario.isBlinking() && !enemy.isDead()
						&& _mario.getJumpTL().getStatus() != Status.RUNNING
						&& enemy.getMoveTL().getStatus() == Status.RUNNING)	{
					pauseAll();
					_mario.die();
				}
				else if (marioSide.intersects(enemy.getBody().getBoundsInLocal())
						&& enemy.isRogue()
						&& enemy.getMoveTL().getStatus() != Status.RUNNING
						&& _mario.getJumpTL().getStatus() != Status.RUNNING)	{
					enemy.move(15*Constants.DISPLACEMENT*_mario.getSpeedWeight()*_mario.getDir().direction(), 0);
					enemy.setDir(_mario.getDir());
					enemy.rogueAction(_mario);
				}
			}
			
			for (Item item : _items)	{
				if (marioSide.intersects(item.getBody().getBoundsInLocal()))	{
					this.initEffect(item);
					_items.remove(item);
					break;
				}
			}






Line marioSide = null;
//			if (_mario.getDir() == Direction.RIGHT)	{
//				marioSide = new Line(_mario.getCollisionLines()[1].getStartX(),
//									_mario.getCollisionLines()[1].getStartY(),
//									_mario.getCollisionLines()[1].getStartX(),
//									_mario.getCollisionLines()[3].getStartY());
//			}
//			else if (_mario.getDir() == Direction.LEFT)	{
//				marioSide = new Line(_mario.getCollisionLines()[0].getStartX(),
//						_mario.getCollisionLines()[0].getStartY(),
//						_mario.getCollisionLines()[0].getStartX(),
//						_mario.getCollisionLines()[2].getStartY());
//			}




	
//	public void detNewDirection(Mario mario)	{
//		Direction dir = Direction.NONE;	//dir is determined by where on the shell mario jumps
//		if (mario.getBody().getX() < _body.getX() + 11*mario.getBody().getWidth()/24)	{
//			dir = Direction.RIGHT;
//		}
//		else if (mario.getBody().getX() + mario.getBody().getWidth() > _body.getX() + 13*mario.getBody().getWidth()/24)	{
//			dir = Direction.LEFT;
//		}
//		super.setDir(dir);
//	}







	
	public void goInShell()	{
		_body.setFill(Constants.KOOPA_SHELL);
		_body.setHeight(_body.getHeight()/1.25);	//makes it less tall
		super.move(0, _body.getHeight()*(1 - 1/1.25) - 1);	//adjusts for new height
		super.setRogue(true);
		super.getMoveTL().pause();
		super.getAnimate().stop();
		super.setSpeedWeight(super.getSpeedWeight()*5);
	}








package Mario;

import java.util.ArrayList;

import javafx.animation.Animation;
import javafx.animation.Animation.Status;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

public class Game	{
	
	private int _colsDeleted;
	private int _pulsateCount = 1;
	private boolean _paused;
	private Mario _mario;
	private Square[][] _squaresOnScreen;
	private Square[][] _squaresOffScreen;
	private Type[][] _map;
	private Type[][] _offScreenMap;
	private ArrayList<Enemy> _enemies;
	private ArrayList<Item> _items;
	private ArrayList<Offensives> _offensives;
	private ArrayList<Pulsating> _pulsating;
	private ArrayList<Character> _uninteractive;
	private Timeline _pulsate;
	private Pane _gamespace;
	private Rectangle _sky;
	private boolean _slowFall;
	
	public Game(Pane gamespace, Rectangle bg, Pane visualize)	{
		_gamespace = gamespace;
		_sky = bg;
		_gamespace.addEventHandler(KeyEvent.KEY_PRESSED, new PressHandler());
		_gamespace.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>()	{
			@Override
			public void handle(KeyEvent event) {
				if (!_paused && !_mario.isDead())	{
					KeyCode keyPressed = event.getCode();
					switch (keyPressed)	{
					case LEFT:
						_mario.getMoveTL().stop();
						_mario.getAnimate().stop();
						if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
							_mario.startingSprite();
						}
						
//						_mario.getBody().setFill(Color.RED);
						break;
					case RIGHT:
						_mario.getMoveTL().stop();
						_mario.getAnimate().stop();
						if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
							_mario.startingSprite();
						}
						
//						_mario.getBody().setFill(Color.RED);
						break;
					case SPACE:
						double minHoldY = (Constants.BLOCKS_HIGH-5)*Constants.BLOCK_LENGTH;
						if (_mario.getVelocity() < 0)	{
							if (_mario.getBody().getY() > minHoldY) {
								_mario.setVelocity(
										-1*Math.pow(2*Constants.GRAVITY*(_mario.getBody().getY() - minHoldY), 0.5));	//kinematics equation
							}
							else	{
								_mario.setVelocity(0);
							}
						}
						break;
					default:
						break;
					}
				}
			}
		});
		this.setupGame();
	}
	
	private void setupGame()	{
		_mario = new Mario(_gamespace, Constants.BLOCKS_HIGH-3, 0);
		this.setupTLs();
		this.setupMap();
		_mario.getBody().toFront();
	}
	
	private void setupMap()	{ //make a new generation system where only blocks on screen are loaded
		Map temp = new Map();
		_enemies = new ArrayList<Enemy>();	//list of enemies on screen
		_items = new ArrayList<Item>();	//items on screen
		_offensives = new ArrayList<Offensives>();	//mario's attacks, e.g. fireballs
		_pulsating = new ArrayList<Pulsating>();	//things that pulsate on screen
		_uninteractive = new ArrayList<Character>();	//characters that the user doesn't interact with
		_squaresOnScreen = new Square[Constants.BLOCKS_HIGH][Constants.BLOCKS_WIDE];
		_squaresOffScreen = new Square[Constants.BLOCKS_HIGH][Constants.OFFSET];
		_map = temp.getMap();
		_offScreenMap = temp.getOffScreen();
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {	//generates the blocks initially on screen
			for (int j = 0 ; j < Constants.BLOCKS_WIDE; j++)	{ 
				_squaresOnScreen[i][j] = this.detNewPiece(i, j);
			}
		}
		Square piece = null;
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {	//generates the blocks initially off screen
			for (int j = 0 ; j < Constants.OFFSET; j++)	{	//offset is how many columns are off screen
				switch (_offScreenMap[i][j])	{
				case FREE:
					piece = new Square(_gamespace, i, j - Constants.OFFSET);
					break;
				case FLOOR:
					piece = new Floor(_gamespace, i, j - Constants.OFFSET);
					break;
				default:
					break;
				}
				_squaresOffScreen[i][j] = piece;
			}
		}
		_sky.toBack();
	}
	
	private Square detNewPiece(int i, int j)	{
		Square piece = null;
		Mystery mystery = null;
		switch (_map[i][j + _colsDeleted])	{
		case PIT:
		case FREE:
			piece = new Square(_gamespace, i, j);
			break;
		case BIGHILL:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*5, Constants.BLOCK_LENGTH*2,
					Constants.BIG_HILL, Type.BIGHILL);
			break;
		case SMALLHILL:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*3, Constants.BLOCK_LENGTH,
					Constants.SMALL_HILL, Type.SMALLHILL);
			break;
		case BIGBUSH:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*5, Constants.BLOCK_LENGTH,
					Constants.BIG_BUSH, Type.BIGBUSH);
			break;
		case MEDBUSH:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*4, Constants.BLOCK_LENGTH,
					Constants.MED_BUSH, Type.MEDBUSH);
			break;
		case SMALLBUSH:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*3, Constants.BLOCK_LENGTH,
					Constants.SMALL_BUSH, Type.SMALLBUSH);
			break;
		case GOOMBA_START:
			piece = new Square(_gamespace, i, j);
			Goomba goomba = new Goomba(_gamespace, i, j);
			this.addNPCKeyFrame(goomba);
			goomba.getMoveTL().play();
			_enemies.add(goomba);
			break;
		case KOOPA_START:
			piece = new Square(_gamespace, i, j);
			Koopa koopa = new Koopa(_gamespace, i, j);
			this.addNPCKeyFrame(koopa);
			koopa.getMoveTL().play();
			_enemies.add(koopa);
			break;
		case FLOOR:
			piece = new Floor(_gamespace, i, j);
			break;
		case BRICK:
			piece = new Brick(_gamespace, i, j);
			break;
		case PIPE_TL:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_TL);
			break;
		case PIPE_TR:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_TR);
			break;
		case PIPE_L:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_L);
			break;
		case PIPE_R:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_R);
			break;
		case STAIR:
			piece = new Stair(_gamespace, i, j);
			break;
		case COIN_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.COIN);
			mystery = (Mystery) piece;
			mystery.pulsate(_pulsateCount);
			_pulsating.add(mystery);
			break;
		case MUSHROOM_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.MUSHROOM);
			mystery = (Mystery) piece;
			mystery.pulsate(_pulsateCount);
			_pulsating.add(mystery);
			break;
		case FLOWER_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.FLOWER);
			mystery = (Mystery) piece;
			mystery.pulsate(_pulsateCount);
			_pulsating.add(mystery);
			break;
		case STAR_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.STAR);
			mystery = (Mystery) piece;
			mystery.pulsate(_pulsateCount);
			_pulsating.add(mystery);
			break;
		default:
			break;
		}
		return piece;
	}
	
	private void addNPCKeyFrame(Character npc)	{
		KeyFrame jump = new KeyFrame(Duration.seconds(Constants.DURATION), new NPCJump(npc));
		npc.getJumpTL().getKeyFrames().add(jump);
		
		KeyFrame move = new KeyFrame(Duration.seconds(Constants.DURATION), new NPCMove(npc));
		npc.getMoveTL().getKeyFrames().add(move);
	}

	private void setupTLs()	{
		_mario.getJumpTL().getKeyFrames().add(new KeyFrame(Duration.seconds(Constants.DURATION), new MVM()));
		_mario.getMoveTL().getKeyFrames().add(new KeyFrame(Duration.seconds(Constants.DURATION/4/*5*/), new MHM()));
		_mario.getChangeForm().getKeyFrames().add(new KeyFrame(Duration.seconds(0.2), "Grow", new Grow()));
		_mario.getBlink().getKeyFrames().add(new KeyFrame(Duration.seconds(0.2), "Blink", new Blink()));

		_mario.getChangeForm().setOnFinished(new EventHandler<ActionEvent>(){
			@Override
	        public void handle(ActionEvent e) {
				if (_mario.getJumpTL().getStatus() == Status.PAUSED) {
					_mario.getBody().setFill(_mario.getJumpSprite());
				}
				else	{
					_mario.getBody().setFill(_mario.getSet()[0]);
				}
				if (!_mario.isBig())	{
					_mario.getBlink().play();
					_mario.blinking(true);
				}
				playAll();
				_mario.getAnimate().stop();
				e.consume();
	        }
		});
		_mario.getBlink().setOnFinished(new EventHandler<ActionEvent>(){
			@Override
	        public void handle(ActionEvent e) {
				_mario.blinking(false);
				if (_mario.getJumpTL().getStatus() == Status.STOPPED) {
					_mario.getBody().setFill(Constants.MARIO1);
				}
				else	{
					_mario.getBody().setFill(Constants.JUMP);
				}
				playAll();
				e.consume();
	        }
		});
		
		_pulsate = new Timeline();
		_pulsate.getKeyFrames().add(new KeyFrame(Duration.seconds(0.4), new Pulsate()));
		_pulsate.setCycleCount(Animation.INDEFINITE);
		_pulsate.play();
	}
	
	public void pauseAll()	{
		_mario.pauseAll();
		for (Enemy enemy : _enemies) {
			enemy.pauseAll();
		}
		for (Item item : _items) {
			item.pauseAll();
		}
		for (Offensives attack : _offensives) {
			attack.pauseAll();
		}
		for (Character character : _uninteractive) {
			character.pauseAll();
		}
		_paused = true;
	}
	
	public void playAll()	{
		_mario.playAll();
		for (Enemy enemy : _enemies) {
			enemy.playAll();
		}
		for (Item item : _items) {
			item.playAll();
		}
		for (Offensives attack : _offensives) {
			attack.playAll();
		}
		for (Character character : _uninteractive) {
			character.playAll();
		}
		_paused = false;
	}
	
	private Square nextBlock(Character character, double xDisplacement, double yDisplacement)	{
		Line collisionLine = null;
		if (yDisplacement == 0)	{
			if (character.getDir() == Direction.LEFT)	{
				collisionLine = character.getCollisionLines()[0];
			}
			else if (character.getDir() == Direction.RIGHT)	{
				collisionLine = character.getCollisionLines()[1];
			}
		}
		else if (xDisplacement == 0)	{
			if (_mario.getVelocity() > 0) {
				collisionLine = character.getFoot();
			}
			else	{
				collisionLine = character.getHead();
			}
		}
		
		Line testLine = new Line(collisionLine.getStartX() + xDisplacement, 
									collisionLine.getStartY() + yDisplacement,
									collisionLine.getEndX() + xDisplacement,
									collisionLine.getEndY() + yDisplacement);
		for (Square[] squares : _squaresOnScreen)	{
			for (Square square : squares)	{
				if (square.getBody().intersects(testLine.getBoundsInLocal())
						&& !square.isFree()) {
					return square;
				}
			}
		}
		return null;
	}

	private class PressHandler implements EventHandler<KeyEvent>	{
		
		public PressHandler()	{}
		
		@Override
		public void handle(KeyEvent event)	{
			if (!_paused && !_mario.isDead())	{
				KeyCode keyPressed = event.getCode();
				switch (keyPressed)	{
				case LEFT:
					if (_mario.getMoveTL().getStatus() != Status.RUNNING)	{
						_mario.setDir(Direction.LEFT);
						_mario.getBody().setRotate(180);
						_mario.getMoveTL().play();
						if (_mario.getAnimate().getStatus() != Status.RUNNING)	{
							_mario.switchCostume();
							_mario.getAnimate().play();
						}
					}
					break;
				case RIGHT:
					if (_mario.getMoveTL().getStatus() != Status.RUNNING)	{
						_mario.setDir(Direction.RIGHT);
						_mario.getBody().setRotate(0);
						_mario.getMoveTL().play();
						if (_mario.getAnimate().getStatus() != Status.RUNNING)	{
							_mario.switchCostume();
							_mario.getAnimate().play();
						}
					}
					break;
				case SPACE:
					if (_mario.getJumpTL().getStatus() == Status.STOPPED/*RUNNING*/) {
						_mario.getBody().setFill(_mario.getJumpSprite());
						_mario.getAnimate().pause();
						_mario.setVelocity(_mario.getInitV());
						_mario.getJumpTL().play();
					}
//					if (_mario.getVelocity() < 0 /*-600*/
//							&& _mario.getVelocity() > Constants.INIT_V*5/6) {
//						_mario.setVelocity(0);
//					}
					break;
				case DOWN:
					break;
				case K:
					_mario.transform();
					break;
				case S:
					_mario.getJumpTL().getKeyFrames().clear();
					if (_slowFall)	{
						_slowFall = false;
						_mario.getJumpTL().getKeyFrames().add(new KeyFrame(Duration.seconds(Constants.DURATION), new MVM()));
					}
					else	{
						_slowFall = true;
						_mario.getJumpTL().getKeyFrames().add(new KeyFrame(Duration.seconds(Constants.DURATION*5), new MVM()));
					}
					break;
				case H:
					if (_mario.getBody().getFill() == Color.RED)	{
						_mario.getBody().setFill(Constants.MARIO1);
					}
					else	{
						_mario.getBody().setFill(Color.RED);
						_mario.getAnimate().stop();
					}
					break;
				case G:
					pauseAll();
					_mario.changeForm();
					break;
				case E:
					System.out.println(_enemies.size());
					break;
				case O:
					System.out.println(_offensives.size());
					break;
				case Q:
					Platform.exit();
					break;
				case F:
					if (_mario.isBig()) {
						Fireball fireball = null;
						if (_mario.getDir() == Direction.RIGHT)	{
							fireball = new Fireball(_gamespace,_mario.getBody().getX() + _mario.getBody().getWidth(), _mario.getBody().getY());
						}
						else	{
							fireball = new Fireball(_gamespace,_mario.getBody().getX() - Constants.BLOCK_LENGTH/3, _mario.getBody().getY());
						}
						
						if (fireball != null)	{
							fireball.setInitV(Constants.INIT_V/2.5);
							fireball.setSpeedWeight(5);
							fireball.setDir(_mario.getDir());
							_offensives.add(fireball);
							addNPCKeyFrame(fireball);
							fireball.getMoveTL().play();
						}
						if (_mario.getCostNum() == 0)	{
							_mario.getBody().setFill(Constants.FIRE_MARIO_SHOOT[0]);
						}
						else	{
							_mario.getBody().setFill(Constants.FIRE_MARIO_SHOOT[_mario.getCostNum()-1]);
						}
						_mario.getReturnToStandard().play();
					}
					break;
				default:
					break;
				}
			}
			
			event.consume();
		}
	}
	//make pause and stop all the same
	
	private class MVM implements EventHandler<ActionEvent>	{

		private ArrayList<Enemy> _removeable;
		
		public MVM()	{
			_removeable = new ArrayList<Enemy>();
		}
		
		@Override
        public void handle(ActionEvent e) {
			_mario.updateVelocity();
			double displacement = _mario.getVelocity() * Constants.DURATION;
			
			if (_mario.isDead())	{
				_mario.move(0, displacement);
			}
			else if (_mario.getVelocity() > 0)	{
				this.goingDown();
			}	
			else if (_mario.getVelocity() <= 0)	{
				this.goingUp();
			}
			
			if (_mario.getBody().getY() > Constants.MAX_Y)	{
				Platform.exit();
			}
			
			_enemies.removeAll(_removeable);
			_removeable.clear();
			
			e.consume();
        }
		
		@SuppressWarnings("unlikely-arg-type")
		private void detBlockAction(Square block)	{
			if (!block.isImpacted())	{
				if (block.getType() == Type.BRICK)	{
					if (_mario.isBig() && block.getBop().getStatus() != Status.RUNNING)	{
						block.delete();
					}
					else	{
						block.getBop().play();
					}
				}
				else if (block.getType() == Type.COIN
						|| block.getType() == Type.MUSHROOM
						|| block.getType() == Type.FLOWER
						|| block.getType() == Type.STAR)	{
					this.newItem(block);
					block.delete();
					_pulsating.remove(block);
				}
				for (Enemy enemy : _enemies)	{ //kills enemies if block under them is hit
					if (block.getBody().intersects(enemy.getCollisionLines()[1].getBoundsInLocal())) {
						if (enemy.getType() == Type.KOOPA) {
							enemy.getBody().setRotationAxis(Rotate.X_AXIS);
							enemy.getBody().setRotate(180);
							enemy.setVelocity(-200);
							enemy.getJumpTL().play();
							enemy.rogueAction(_mario);//Direction.NONE);
						}
						else	{
							enemy.deathAnimation();
						}
					}
				}
			}
		}
		
		private void newItem(Square block)	{
			//puts an item on the screen depending on what block was hit
			Item item = null;
			switch (block.getType())	{
			case COIN:
				_uninteractive.add(new Coin(_gamespace, block.getBody().getY()/Constants.BLOCK_LENGTH, block.getBody().getX()/Constants.BLOCK_LENGTH, Type.COIN));
				break;
			case MUSHROOM:
				item = new Mushroom(_gamespace, block.getBody().getY()/Constants.BLOCK_LENGTH, block.getBody().getX()/Constants.BLOCK_LENGTH, Type.MUSHROOM);
				addNPCKeyFrame(item);
				break;
			case FLOWER:
				item = new Flower(_gamespace, block.getBody().getY()/Constants.BLOCK_LENGTH, block.getBody().getX()/Constants.BLOCK_LENGTH, Type.FLOWER);
				addNPCKeyFrame(item);
				break;
			case STAR:
				item = new Star(_gamespace, block.getBody().getY()/Constants.BLOCK_LENGTH, block.getBody().getX()/Constants.BLOCK_LENGTH, Type.STAR);
				addNPCKeyFrame(item);
				break;
			default:
				break;
			}
			_sky.toBack();
			if (item!=null)	{
				_items.add(item);
			}
			_sky.toBack();
		}
		
		private void detEnemyAction(Enemy enemy)	{
			//initiates an enemy's reponse to being jumped on
			switch (enemy.getType())	{
			case GOOMBA:
				enemy.delete();
				_enemies.remove(enemy);
				_uninteractive.add((Character) enemy);
				break;
			case KOOPA:
				enemy.rogueAction(_mario);
				
//				enemy.getBody().setFill(Color.RED);
				//if mario touches the bottom half he dies
				break;
			default:
				break;
			}
		}
		
		private void goingUp()	{
			double displacement = _mario.getVelocity() * Constants.DURATION;
			Square nextBlock = nextBlock(_mario, 0, displacement);
			if (nextBlock != null)	{
				_mario.setVelocity(_mario.getVelocity()*-1);
				this.detBlockAction(nextBlock);
			}
			_mario.move(0,displacement);
		}
		
		private void goingDown()	{
			double displacement = _mario.getVelocity() * Constants.DURATION;
//			Line foot = _mario.getCollisionLines()[1];
			Line foot = _mario.getFoot();
			Rectangle enemyHead = null;
			if (nextBlock(_mario, 0, displacement) != null && !_mario.isDead())	{	//when it lands
//				_mario.move(0,1);
				_mario.onHittingGround();
			}
			else	{ 
				_mario.move(0,displacement);
			}
			
			for (Enemy enemy : _enemies)	{	//checks to see if mario is jumping on an enemy
				enemyHead = new Rectangle(enemy.getBody().getX(), enemy.getBody().getY(), 
						enemy.getBody().getWidth(), enemy.getBody().getHeight()/2);
				if (enemyHead.intersects(foot.getBoundsInLocal())
						&& !enemy.isDead())	{
					_mario.setVelocity(_mario.getInitV());
					this.detEnemyAction(enemy);
					break;	//patch
				}
			}
		}
		
	}
	
	private class MHM implements EventHandler<ActionEvent>	{

		public MHM()	{}
	
		@Override
        public void handle(ActionEvent e) {
			
			this.determineAction();
			this.checkCollisions();
			
			e.consume();
        }
		
		private void determineAction()	{
			double displacement = _mario.getDir().direction()*Constants.DISPLACEMENT*_mario.getSpeedWeight();
			if (_mario.isDead()) {	//prioritizes falling to the bottom of the screen if dead
				_mario.move(displacement, 0);
			}
			else if (nextBlock(_mario, 0, 1) == null
					&& _mario.getJumpTL().getStatus() == Status.STOPPED)	{	//acts as a gravity simulation
				_mario.fall();
			}
			else if (nextBlock(_mario, displacement, 0) == null)	{ //if mario is moving to a free block
				if (_mario.getBody().getX() >= Constants.MAX_X
						&& _colsDeleted < Constants.TOT_BLOCKS_WIDE - Constants.BLOCKS_WIDE) {	//if mario is at scrolling distance and the end of the level is not reached
					this.adjustSquares();
					this.checkScroll();
				}
				_mario.move(displacement,0);
			}
		}
		
		private void checkCollisions()	{
			Rectangle deathZone = null;
			for (Enemy enemy : _enemies)	{
				deathZone = new Rectangle(enemy.getBody().getX(), enemy.getBody().getY() + 3*enemy.getBody().getHeight()/4, 
						enemy.getBody().getHeight(), enemy.getBody().getHeight()/4);
				if (_mario.getBody().intersects(deathZone.getBoundsInLocal()) && !_mario.isDead() 
						&& !_mario.isBlinking() && !enemy.isDead()
						&& _mario.getJumpTL().getStatus() != Status.RUNNING
						&& enemy.getMoveTL().getStatus() == Status.RUNNING)	{
					pauseAll();
					_mario.die();
				}
				else if (_mario.getBody().intersects(enemy.getBody().getBoundsInLocal())
						&& enemy.isRogue()
						&& enemy.getMoveTL().getStatus() != Status.RUNNING)	{
					enemy.getBody().setX(enemy.getBody().getX() + 15*Constants.DISPLACEMENT*_mario.getSpeedWeight()*_mario.getDir().direction());
					enemy.rogueAction(_mario);
				}
			}
			
			for (Item item : _items)	{
				if (_mario.getBody().intersects(item.getBody().getBoundsInLocal()))	{
					this.initEffect(item);
					_items.remove(item);
					break;
				}
			}
		}
		
		private void initEffect(Item item)	{
			switch (item.getType())	{
			case MUSHROOM:
				pauseAll();
				_mario.changeForm();
				break;
			case FLOWER:
				_mario.transform();
				break;
			case STAR:
				_mario.invincible();
				break;
			default:
				break;
			}
			item.delete();
		}
	
		private void checkScroll()	{
			if (_squaresOnScreen[0][0].getBody().getX() <= -1 * Constants.BLOCK_LENGTH) {
				this.shiftArrays();
				_mario.getBody().toFront();
				if (_colsDeleted != Constants.TOT_BLOCKS_WIDE + Constants.BLOCKS_WIDE)	{
					_colsDeleted++;
				}
			}
		}
		
		private void shiftArrays()	{
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++)	{	//moves columns of array one space to the left
				for (int j = 1 ; j < Constants.OFFSET; j++)	{
					_squaresOffScreen[i][j-1] = _squaresOffScreen[i][j];
				}
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++)	{	//moves the leftmost column of onscreen to rightmost of offscreen
				_squaresOffScreen[i][Constants.OFFSET-1] = _squaresOnScreen[i][0];
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH; i++)	{	//moves columns of array one space to the left
				for (int j = 1 ; j < Constants.BLOCKS_WIDE; j++)	{
					_squaresOnScreen[i][j-1] = _squaresOnScreen[i][j];
				}
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {	//generate new squares, going down the column
				_squaresOnScreen[i][Constants.BLOCKS_WIDE-1] = 
						detNewPiece(i, Constants.BLOCKS_WIDE-1);
			}
			for (Enemy enemy : _enemies)	{
				enemy.getBody().toFront();
			}
			for (Offensives attack : _offensives)	{
				attack.getBody().toFront();
			}
		}
		
		private void adjustSquares()	{
			for (Square[] pieces : _squaresOffScreen)	{
				for (Square piece : pieces)	{
					piece.getBody().setX(piece.getBody().getX() - Constants.DISPLACEMENT*_mario.getSpeedWeight());
					if (piece.getBody().getX() < -1 * piece.getBody().getWidth() - Constants.OFFSET*Constants.BLOCK_LENGTH)	{
						piece.delete();
					}
				}
			}
			for (Square[] squares : _squaresOnScreen)	{
				for (Square square : squares)	{
					square.getBody().setX(square.getBody().getX() - Constants.DISPLACEMENT*_mario.getSpeedWeight());
				}
			}
			for (Enemy enemy : _enemies) {
				enemy.move(-1*Constants.DISPLACEMENT*_mario.getSpeedWeight(), 0);
				if (enemy.getBody().getX() < -1 * Constants.OFFSET*Constants.BLOCK_LENGTH)	{
					_enemies.remove(enemy);
					enemy = null;
					break;
				}
			}
			ArrayList<Character> entities = new ArrayList<Character>();
			ArrayList<Character> removeable = new ArrayList<Character>();
			entities.addAll(_items);	entities.addAll(_offensives);	entities.addAll(_uninteractive);
			for (Character entity : entities) {
				entity.move(-1*Constants.DISPLACEMENT*_mario.getSpeedWeight(), 0);
				if (entity.getBody().getX() < -Constants.OFFSET*Constants.BLOCK_LENGTH)	{
					removeable.add(entity);
				}
			}
			_items.removeAll(removeable);	_offensives.removeAll(removeable);	_uninteractive.removeAll(removeable);
		}
		}
	
	private class NPCJump implements EventHandler<ActionEvent>	{

		private Character _jumping;
		
		public NPCJump(Character jumping)	{
			_jumping = jumping;
		}
		
		@SuppressWarnings("unlikely-arg-type")
		@Override
        public void handle(ActionEvent e) {
			double displacement = _jumping.getVelocity() * Constants.DURATION;
			_jumping.updateVelocity();
			
			if (_jumping.isDead())	{
				_jumping.move(0, displacement);
			}
			else if (_jumping.getVelocity() > 0)	{
				this.goingDown();
			}	
			else if (_jumping.getVelocity() <= 0)	{
				this.goingUp();
			}
			
			if (_jumping.getBody().getY() > Constants.MAX_Y)	{
				_enemies.remove(_jumping);	_items.remove(_jumping);	_offensives.remove(_jumping);	_uninteractive.remove(_jumping);
				_gamespace.getChildren().remove(_jumping.getBody());
				_jumping.pauseAll();
			}
			
//			if (_jumping.getBody().intersects(_mario.getBody().getBoundsInLocal())
//					&& _jumping.getType() == Type.KOOPA
//					&& _jumping.isRogue()
//					&& _jumping.getMoveTL().getStatus() != Status.RUNNING)	{	//handles edge case when a koopa is in its shell and falling
//				_jumping
//			}
			
			e.consume();
        }
		
		private void goingDown()	{
			double displacement = _jumping.getVelocity() * Constants.DURATION;
			Square nextBlock = nextBlock(_jumping, 0, displacement);
			if (nextBlock != null && !_jumping.isDead())	{	//when it lands
				_jumping.onHittingGround();
			}
			else	{ 
				_jumping.move(0, displacement);
			}
		}
		
		private void goingUp()	{
			double displacement = _jumping.getVelocity() * Constants.DURATION;
			if (nextBlock(_jumping, 0, displacement) != null)	{
				_jumping.setVelocity(_jumping.getVelocity()*-1);
			}
			_jumping.move(0, displacement);
		}
		
	}
	
	private class NPCMove implements EventHandler<ActionEvent>	{

		private Character _moving;
		
		public NPCMove(Character npc)	{
			_moving = npc;
		}
	
		@Override
        public void handle(ActionEvent e) {
			
			this.checkCollisions();
			this.determineAction();
			this.checkForAttacks();
			
			e.consume();
        }
		
		private void initEffect()	{
			switch (_moving.getType())	{
			case MUSHROOM:
				pauseAll();
				_mario.changeForm();
				break;
			case FLOWER:
				_mario.transform();
				break;
			case STAR:
				_mario.invincible();
				break;
			default:
				break;
			}
			_moving.delete();
			_items.remove(_moving);
		}
		
		@SuppressWarnings("unlikely-arg-type")
		private boolean nextToNPC()	{
			int index = 0;
			if (_moving.getDir() == Direction.LEFT) {
				index = 0;
			}
			else if (_moving.getDir() == Direction.RIGHT) {
				index = 1;
			}
			Line sideFacing  = _moving.getCollisionLines()[index];
			for (Enemy enemy : _enemies)	{
				if (enemy.getBody().intersects(sideFacing.getBoundsInLocal())
						&& !enemy.equals(_moving))	{
					return true;
				}
			}
			for (Item item : _items)	{
				if (item.getBody().intersects(sideFacing.getBoundsInLocal())
						&& !item.equals(_moving))	{
					return true;
				}
			}
			return false;
		}
	
		private void checkForAttacks()	{
			for (Enemy enemy : _enemies)	{
				if (enemy.getBody().intersects(_moving.getBody().getBoundsInLocal())
						&& _offensives.contains(_moving)
						&& !enemy.isDead())	{
					enemy.deathAnimation(); 
					_moving.delete();
					_offensives.remove(_moving);
				}
			}
		}
		
		private void checkCollisions()	{
			Rectangle body = _moving.getBody();
			Rectangle deathZone = new Rectangle(body.getX(), body.getY() + 3*body.getHeight()/4, 
					body.getHeight(), body.getHeight()/4);
			if (_mario.getBody().intersects(deathZone.getBoundsInLocal()) && !_mario.isDead() && !_mario.isBlinking()
					& !_moving.isDead() && _moving.isEnemy())	{
				if (_moving.getMoveTL().getStatus() == Status.RUNNING) {
					pauseAll();
					_mario.die();
				}
			}
			else if (_moving.getBody().intersects(_mario.getBody().getBoundsInLocal())
					&& _moving.isNPC() && !_moving.isEnemy())	{
				this.initEffect();
			}
		}
	
		private void determineAction()	{
			double displacement = _moving.getDir().direction()*Constants.DISPLACEMENT*_moving.getSpeedWeight();
			if (_moving.isDead()) {
				_moving.move(displacement, 0);
			}
			else if (nextBlock(_moving, 0, 1) == null
					&& _moving.getJumpTL().getStatus() == Status.STOPPED)	{
				_moving.fall();
			}
			else if (nextBlock(_moving, displacement, 0) == null
					&& (!nextToNPC() || _moving.isRogue()))	{
				_moving.move(displacement,0);
			}
			else if (!_moving.isDead())	{
				_moving.flip();
			}
		}
	}
	
	private class Pulsate implements EventHandler<ActionEvent>	{

		@Override
		public void handle(ActionEvent event) {
			if (!_pulsating.isEmpty())	{
				for (Pulsating pulsable : _pulsating)	{
					pulsable.pulsate(_pulsateCount);
				}
				if (_pulsateCount == Constants.MYSTERY_SET.length-1)	{
					_pulsateCount = 0;
				}
				else	{
					_pulsateCount++;
				}
			}
		}
		
	}
	
	private class Grow implements EventHandler<ActionEvent>	{

		private int _count = 1;
		@Override
        public void handle(ActionEvent e) {
			Rectangle body = _mario.getBody();
			if (_count%2==1)	{	//look like big mario
				body.setHeight(2*Constants.BLOCK_LENGTH);
				if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
					body.setY(body.getY() - Constants.BLOCK_LENGTH);
				}
				_mario.setCostumes(Constants.BIG_MARIO);
				_mario.setJumpSprite(Constants.BIG_JUMP);
				_mario.setBig(true);
			}
			else	{	//look like little mario
				body.setHeight(Constants.BLOCK_LENGTH);
				if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
					body.setY(body.getY() + Constants.BLOCK_LENGTH);
				}
				_mario.setCostumes(Constants.MARIO);
				_mario.setJumpSprite(Constants.JUMP);
				_mario.setBig(false);
			}
//			if (getCostNum() == 0)	{
//				setCostNum(1);
//			}
			if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
				if (_mario.getCostNum() == 0)	{
					body.setFill(_mario.getSet()[0]);
				}
				else	{
					body.setFill(_mario.getSet()[_mario.getCostNum() - 1]);
				}
			}
			else	{
				body.setFill(_mario.getJumpSprite());
			}
			_count++;
			
			e.consume();
        }
		
	}
	
	private class Blink implements EventHandler<ActionEvent>	{

		@Override
        public void handle(ActionEvent e) {
			if (_gamespace.getChildren().contains(_mario.getBody()))	{
				_gamespace.getChildren().remove(_mario.getBody());
			}
			else	{
				_gamespace.getChildren().add(_mario.getBody());
			}
			
			e.consume();
        }
		
	}
	
}










package Mario;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;

import java.lang.reflect.Array;

import javafx.animation.Animation.Status;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.layout.Pane;
import javafx.scene.paint.ImagePattern;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

public class Mario extends Character	{
	
	private Rectangle _body;
	private ImagePattern _jumpSprite;
	private Timeline _changeForm;
	private Timeline _blinking;
	private Timeline _goBackToStandard;
	private boolean _isBig;
	private boolean _isBlinking;
	private Line _top;
	private Line _bottom;
	private Line _left;
	private Line _right;
	private double[][] _pointsArray;
	
	public Mario(Pane parent, int i, int j)	{
		super(parent,i,j);
		_body = super.getBody();
		_body.setFill(Constants.MARIO1);
		_body.setRotationAxis(Rotate.Y_AXIS);
		_jumpSprite = Constants.JUMP;
		super.setCostumes(Constants.MARIO);
		super.setNPC(false);
		super.setType(Type.MARIO);
		super.getAnimate().stop();
		_pointsArray = new double[][] {new double[] {4,1,-4,0,4,0,-4,0,2,-3,0,-7,-2,-3,0,-7},
										new double[] {}};
	}
	
	public void adjustCollisionLines()	{
		_top = super.getCollisionLines()[0];
		_bottom = super.getCollisionLines()[1];
		_left = super.getCollisionLines()[2];
		_right = super.getCollisionLines()[3];
		
		this.moveLine(_top, 4, 1);
		this.resizeLine(_top, -4, 0);
		this.moveLine(_bottom, 4, 0);
		this.resizeLine(_bottom, -4, 0);
		this.moveLine(_left, 2, -3);
		this.resizeLine(_left, 0, -7);
		this.moveLine(_right, -2, -3);
		this.resizeLine(_right, 0, -7);
	}
	
	private void adjustLine(Line line, double xDisplacement, double yDisplacement)	{
		//in relation to body as a whole
		line.setStartX(line.getStartX() + xDisplacement);
		line.setStartY(line.getStartY() + yDisplacement);
	}
	
	private void resizeLine(Line line, double xPixels, double yPixels)	{
		line.setEndX(line.getEndX() + xPixels);
		line.setEndY(line.getEndY() + yPixels);
	}
	
	public boolean isBlinking()	{
		return _isBlinking;
	}
	
	public boolean isBig()	{
		return _isBig;
	}
	
	public Timeline getChangeForm()	{
		return _changeForm;
	}
	
	public Timeline getBlink()	{
		return _blinking;
	}
	
	public Timeline getReturnToStandard()	{
		return _goBackToStandard;
	}
	
	public ImagePattern getJumpSprite()	{
		return _jumpSprite;
	}
	
	public void blinking(boolean yn)	{
		_isBlinking = yn;
	}
	
	public void setBig(boolean yn)	{
		_isBig = yn;
	}
	
	public void setJumpSprite(ImagePattern sprite)	{
		_jumpSprite = sprite;
	}
	
	@Override
	public void setupTLs()	{
		super.setupTLs();

		_changeForm = new Timeline();
		_changeForm.setCycleCount(7);	//must be odd
		
		_blinking = new Timeline();
		_blinking.setCycleCount(12);	//must be even
		
		_goBackToStandard = new Timeline();
		_goBackToStandard.setCycleCount(1);
		_goBackToStandard.getKeyFrames().add(new KeyFrame(Duration.seconds(0.2),
				new EventHandler<ActionEvent>()	{

					@Override
					public void handle(ActionEvent event) {
						if (getCostNum() == 0)	{
							_body.setFill(getSet()[0]);
						}
						else	{
							_body.setFill(getSet()[getCostNum()-1]);
						}
						if (getAnimate().getStatus() == Status.PAUSED)	{
							getAnimate().play();
						}
					}
			
		}));
		
	}
	
	@Override
	public void fall()	{
		super.fall();
		_body.setFill(_jumpSprite);
	}
	
	@Override
	public void onHittingGround()	{
		super.onHittingGround();
		_body.setFill(super.getSet()[0]);
	}
	
	@Override
	public void move(double xDisplacement, double yDisplacement)	{
		double newX = _body.getX() + xDisplacement;
		if (newX >= Constants.MIN_X && newX <= Constants.MAX_X)	{
			super.move(xDisplacement, yDisplacement);
		}
	}
	
	public void changeForm()	{
		super.getAnimate().stop();
		_changeForm.play();
	}
	
	public void die()	{
		if (_isBig)	{
			this.changeForm();
		}
		else	{
			super.getMoveTL().stop();
			super.getJumpTL().stop();
			super.setVelocity(-200);
			super.setDead(true);
			super.getBody().setFill(Constants.DEAD);
			_body.setY(_body.getY()-_body.getY()%Constants.BLOCK_LENGTH); //uhhhhhhhhhhhhh
			super.getJumpTL().play();
		}
	}
	
	public void transform()	{
		super.getAnimate().pause();
		super.setCostumes(Constants.FIRE_MARIO);
		this.setBig(true);
		_body.setFill(Constants.FIRE_MARIO1);
		_body.setHeight(2*Constants.BLOCK_LENGTH);
		if (super.getJumpTL().getStatus() == Status.STOPPED)	{
			_body.setY(_body.getY() - Constants.BLOCK_LENGTH);
		}
		_jumpSprite = Constants.FIRE_JUMP;
	}
	
	public void invincible()	{
		
	}
	
}







package Mario;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.animation.Animation.Status;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.paint.ImagePattern;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

public class Character	{
	
	private double _v;
	private double _initV;
	private double _speedWeight = 1;
	private boolean _isDead;
	private boolean _isNpc;
	private boolean _isEnemy;
	private boolean _isRogue;
	private int _costNum = 1;
	private Timeline _moveTL;
	private Timeline _jumpTL;
	private Timeline _animate;
	private Direction _dir;
	private Rectangle _body;
	private Type _type;
	private Pane _parent;
	private ImagePattern[] _costSet;
	private Rectangle _top;
	private Rectangle _bottom;
	private Rectangle _left;
	private Rectangle _right;
	private Rectangle[] _collisionPoints;
	
	public Character(Pane parent, double i, double j)	{
		_dir = Direction.LEFT;
		_body = new Rectangle(j*Constants.BLOCK_LENGTH,i*Constants.BLOCK_LENGTH-1,
				Constants.BLOCK_LENGTH,Constants.BLOCK_LENGTH);
		_body.setRotationAxis(Rotate.Y_AXIS);
		_type = Type.NONE;
		_parent = parent;
		_parent.getChildren().add(_body);
		_initV = Constants.INIT_V;
		_isNpc = true;	//generally a character is an npc
		this.setupTLs();
		this.setupCollisionPoints();
	}
	
	public void setupTLs()	{
		_moveTL = new Timeline();
		_moveTL.setCycleCount(Animation.INDEFINITE);

		_jumpTL = new Timeline();
		_jumpTL.setCycleCount(Animation.INDEFINITE);
		
		_animate = new Timeline();
		_animate.setCycleCount(Animation.INDEFINITE);
		KeyFrame animate = new KeyFrame(Duration.seconds(0.1), "Animate",
				new EventHandler<ActionEvent>()	{
					@Override
					public void handle(ActionEvent event) {
						if (isDead())	{
							_animate.stop();
						}
						else	{
							switchCostume();
						}
					}
		});
		_animate.getKeyFrames().add(animate);
		_animate.play();
	}
	
	public void setupCollisionPoints()	{
		_top = new Rectangle(_body.getX(), _body.getY() - 1, 1, 1);
		_top.setStroke(Color.RED);
		_top.toFront();
		_bottom = new Rectangle(_body.getX(), _body.getY() + _body.getHeight() + 1, 1, 1);
		_bottom.setStroke(Color.GREEN);
		_bottom.toFront();
		_left = new Rectangle(_body.getX() - 1, _body.getY() + _body.getHeight(), 1, 1);
		_left.setStroke(Color.BLUE);
		_left.toFront();
		_right = new Rectangle(_body.getX() + _body.getWidth() + 1, _body.getY() + _body.getHeight(), 1, 1);
		_right.setStroke(Color.YELLOW);
		_right.toFront();
		_parent.getChildren().addAll(_top,_bottom,_left,_right);
		_collisionPoints = new Rectangle[] {_top,_bottom,_left,_right};
	}
	
	public Rectangle getBody()	{
		return _body;
	}
	
	public Rectangle[] getCollisionPoints()	{
		//indexed as : top, bottom, left, right
		return _collisionPoints;
	}
	
	public Timeline getMoveTL()	{
		return _moveTL;
	}
	
	public Timeline getJumpTL()	{
		return _jumpTL;
	}
	
	public boolean isRogue()	{
		return _isRogue;
	}
	
	public boolean isNPC()	{
		return _isNpc;
	}
	
	public boolean isEnemy()	{
		return _isEnemy;
	}
	
	public boolean isDead()	{
		return _isDead;
	}
	
	public double getSpeedWeight()	{
		return _speedWeight;
	}
	
	public double getVelocity()	{
		return _v;
	}
	
	public double getInitV()	{
		return _initV;
	}
	
	public Direction getDir()	{
		return _dir;
	}

	public Type getType() {
		return _type;
	}
	
	public Timeline getAnimate()	{
		return _animate;
	}
	
	public ImagePattern[] getSet()	{
		return _costSet;
	}
	
	public int getCostNum()	{
		return _costNum;
	}
	
	public void setRogue (boolean yn)	{
		_isRogue = yn;
	}
	
	public void setNPC(boolean yn)	{
		_isNpc = yn;
	}
	
	public void setEnemy(boolean yn)	{
		_isEnemy = yn;
	}
	
	public void setDead(boolean b)	{
		_isDead = b;
	}
	
	public void setSpeedWeight(double weight)	{
		_speedWeight = weight;
	}
	
	public void setVelocity(double v)	{
		_v = v;
	}
	
	public void updateVelocity()	{
		_v = _v + Constants.GRAVITY*Constants.DURATION;
	}
	
	public void setDir(Direction dir)	{
		_dir = dir;
	}
	
	public void setType(Type type)	{
		_type = type;
	}
	
	public void setCostNum(int index)	{
		_costNum = index;
	}
	
	public void setInitV(double v)	{
		_initV = v;
	}
	
	public void delete() {
		_parent.getChildren().remove(_body);
		for (Rectangle point : _collisionPoints)	{
			_parent.getChildren().remove(point);
		}
	}
	
	public void fall()	{
		_v = 0;
		_animate.pause();
		_jumpTL.play();
	}
	
	public void flip()	{
		_dir = _dir.opposite();
		if (!_isRogue)	{
			_body.setRotate(180 + _body.getRotate());
		}
	}
	
	public void move(double xDisplacement, double yDisplacement)	{
		_body.setX(_body.getX() + xDisplacement);
		_body.setY(_body.getY() + yDisplacement);
		for (Rectangle point : _collisionPoints)	{
			point.setX(point.getX() + xDisplacement);
			point.setY(point.getY() + yDisplacement);
		}
	}
	
	public void startingSprite()	{
		_body.setFill(_costSet[0]);
		_costNum = 0;
	}
	
	public void setCostumes(ImagePattern[] cost)	{
		_costSet = cost;
	}
	
	public void switchCostume()	{
		if (_costSet != null && _jumpTL.getStatus() != Status.RUNNING)	{	//will be null for mushroom, star, and flower
			if (_costNum == _costSet.length)	{
				_costNum = 1;
			}
			_body.setFill(_costSet[_costNum]);
			_costNum++;
		}
	}
	
	public void onHittingGround()	{
		_v = _initV;
		_jumpTL.stop();
		if (_animate.getStatus() == Status.PAUSED) {
			this.switchCostume();
			_animate.play();
		}
	}
	
	public void deathAnimation() {
		_isDead = true;
		this.pauseAll();
		_body.setRotationAxis(Rotate.X_AXIS);
		_body.setRotate(180 + _body.getRotate());
		_dir = Direction.RIGHT;
		_v = -200;
		_jumpTL.play();
		_moveTL.play();
	}
	
	public void pauseAll()	{
		_jumpTL.pause();
		_moveTL.pause();
		_animate.pause();
	}
	
	public void playAll()	{
		if (_moveTL.getStatus() != Status.STOPPED && _type != Type.MARIO
				&& !_isRogue)	{
			_moveTL.play();
		}
		if (_jumpTL.getStatus() != Status.STOPPED)	{
			_jumpTL.play();
		}
		if (_animate.getStatus() != Status.STOPPED)	{
			_animate.play();
		}
	}
	
}


package Mario;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.animation.Animation.Status;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.paint.ImagePattern;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

public class Character	{
	
	private double _v;
	private double _initV;
	private double _speedWeight = 1;
	private boolean _isDead;
	private boolean _isNpc;
	private boolean _isEnemy;
	private boolean _isRogue;
	private int _costNum = 1;
	private Timeline _moveTL;
	private Timeline _jumpTL;
	private Timeline _animate;
	private Direction _dir;
	private Rectangle _body;
	private Type _type;
	private Pane _parent;
	private ImagePattern[] _costSet;
	private Rectangle _top;
	private Rectangle _bottom;
	private Rectangle _left;
	private Rectangle _right;
	private Rectangle[] _collisionPoints;
	
	public Character(Pane parent, double i, double j)	{
		_dir = Direction.LEFT;
		_body = new Rectangle(j*Constants.BLOCK_LENGTH,i*Constants.BLOCK_LENGTH-1,
				Constants.BLOCK_LENGTH,Constants.BLOCK_LENGTH);
		_body.setRotationAxis(Rotate.Y_AXIS);
		_type = Type.NONE;
		_parent = parent;
		_parent.getChildren().add(_body);
		_initV = Constants.INIT_V;
		_isNpc = true;	//generally a character is an npc
		this.setupTLs();
		this.setupCollisionPoints();
	}
	
	public void setupTLs()	{
		_moveTL = new Timeline();
		_moveTL.setCycleCount(Animation.INDEFINITE);

		_jumpTL = new Timeline();
		_jumpTL.setCycleCount(Animation.INDEFINITE);
		
		_animate = new Timeline();
		_animate.setCycleCount(Animation.INDEFINITE);
		KeyFrame animate = new KeyFrame(Duration.seconds(0.1), "Animate",
				new EventHandler<ActionEvent>()	{
					@Override
					public void handle(ActionEvent event) {
						if (isDead())	{
							_animate.stop();
						}
						else	{
							switchCostume();
						}
					}
		});
		_animate.getKeyFrames().add(animate);
		_animate.play();
	}
	
	public void setupCollisionPoints()	{
		_top = new Rectangle(_body.getX(), _body.getY() - 1, 1, 1);
		_top.setStroke(Color.RED);
		_top.toFront();
		_bottom = new Rectangle(_body.getX(), _body.getY() + _body.getHeight() + 1, 1, 1);
		_bottom.setStroke(Color.GREEN);
		_bottom.toFront();
		_left = new Rectangle(_body.getX() - 1, _body.getY() + _body.getHeight(), 1, 1);
		_left.setStroke(Color.BLUE);
		_left.toFront();
		_right = new Rectangle(_body.getX() + _body.getWidth() + 1, _body.getY() + _body.getHeight(), 1, 1);
		_right.setStroke(Color.YELLOW);
		_right.toFront();
		_parent.getChildren().addAll(_top,_bottom,_left,_right);
		_collisionPoints = new Rectangle[] {_top,_bottom,_left,_right};
	}
	
	public Rectangle getBody()	{
		return _body;
	}
	
	public Rectangle[] getCollisionPoints()	{
		//indexed as : top, bottom, left, right
		return _collisionPoints;
	}
	
	public Timeline getMoveTL()	{
		return _moveTL;
	}
	
	public Timeline getJumpTL()	{
		return _jumpTL;
	}
	
	public boolean isRogue()	{
		return _isRogue;
	}
	
	public boolean isNPC()	{
		return _isNpc;
	}
	
	public boolean isEnemy()	{
		return _isEnemy;
	}
	
	public boolean isDead()	{
		return _isDead;
	}
	
	public double getSpeedWeight()	{
		return _speedWeight;
	}
	
	public double getVelocity()	{
		return _v;
	}
	
	public double getInitV()	{
		return _initV;
	}
	
	public Direction getDir()	{
		return _dir;
	}

	public Type getType() {
		return _type;
	}
	
	public Timeline getAnimate()	{
		return _animate;
	}
	
	public ImagePattern[] getSet()	{
		return _costSet;
	}
	
	public int getCostNum()	{
		return _costNum;
	}
	
	public void setRogue (boolean yn)	{
		_isRogue = yn;
	}
	
	public void setNPC(boolean yn)	{
		_isNpc = yn;
	}
	
	public void setEnemy(boolean yn)	{
		_isEnemy = yn;
	}
	
	public void setDead(boolean b)	{
		_isDead = b;
	}
	
	public void setSpeedWeight(double weight)	{
		_speedWeight = weight;
	}
	
	public void setVelocity(double v)	{
		_v = v;
	}
	
	public void updateVelocity()	{
		_v = _v + Constants.GRAVITY*Constants.DURATION;
	}
	
	public void setDir(Direction dir)	{
		_dir = dir;
	}
	
	public void setType(Type type)	{
		_type = type;
	}
	
	public void setCostNum(int index)	{
		_costNum = index;
	}
	
	public void setInitV(double v)	{
		_initV = v;
	}
	
	public void delete() {
		_parent.getChildren().remove(_body);
		for (Rectangle point : _collisionPoints)	{
			_parent.getChildren().remove(point);
		}
	}
	
	public void fall()	{
		_v = 0;
		_animate.pause();
		_jumpTL.play();
	}
	
	public void flip()	{
		_dir = _dir.opposite();
		if (!_isRogue)	{
			_body.setRotate(180 + _body.getRotate());
		}
	}
	
	public void move(double xDisplacement, double yDisplacement)	{
		_body.setX(_body.getX() + xDisplacement);
		_body.setY(_body.getY() + yDisplacement);
		for (Rectangle point : _collisionPoints)	{
			point.setX(point.getX() + xDisplacement);
			point.setY(point.getY() + yDisplacement);
		}
	}
	
	public void startingSprite()	{
		_body.setFill(_costSet[0]);
		_costNum = 0;
	}
	
	public void setCostumes(ImagePattern[] cost)	{
		_costSet = cost;
	}
	
	public void switchCostume()	{
		if (_costSet != null && _jumpTL.getStatus() != Status.RUNNING)	{	//will be null for mushroom, star, and flower
			if (_costNum == _costSet.length)	{
				_costNum = 1;
			}
			_body.setFill(_costSet[_costNum]);
			_costNum++;
		}
	}
	
	public void onHittingGround()	{
		_v = _initV;
		_jumpTL.stop();
		if (_animate.getStatus() == Status.PAUSED) {
			this.switchCostume();
			_animate.play();
		}
	}
	
	public void deathAnimation() {
		_isDead = true;
		this.pauseAll();
		_body.setRotationAxis(Rotate.X_AXIS);
		_body.setRotate(180 + _body.getRotate());
		_dir = Direction.RIGHT;
		_v = -200;
		_jumpTL.play();
		_moveTL.play();
	}
	
	public void pauseAll()	{
		_jumpTL.pause();
		_moveTL.pause();
		_animate.pause();
	}
	
	public void playAll()	{
		if (_moveTL.getStatus() != Status.STOPPED && _type != Type.MARIO
				&& !_isRogue)	{
			_moveTL.play();
		}
		if (_jumpTL.getStatus() != Status.STOPPED)	{
			_jumpTL.play();
		}
		if (_animate.getStatus() != Status.STOPPED)	{
			_animate.play();
		}
	}
	
}


public void setupCollisionLines()	{
		_top = new Line(_body.getX(), _body.getY() - 1, _body.getX() + _body.getWidth(), _body.getY() - 1);
		_top.setStroke(Color.RED);
		_top.toFront();
		_bottom = new Line(_body.getX(), _body.getY() + _body.getHeight() + 1, _body.getX() + _body.getWidth(), _body.getY() + _body.getHeight() + 1);
		_bottom.setStroke(Color.GREEN);
		_bottom.toFront();
		_left = new Line(_body.getX() - 1, _body.getY() + _body.getHeight(), _body.getX() - 1, _body.getY());
		_left.setStroke(Color.BLUE);
		_left.toFront();
		_right = new Line(_body.getX() + _body.getWidth() + 1, _body.getY() + _body.getHeight(), _body.getX() + _body.getWidth() + 1, _body.getY());
		_right.setStroke(Color.YELLOW);
		_right.toFront();
		_parent.getChildren().addAll(_top,_bottom,_left,_right);
		_collisionLines = new Line[] {_top,_bottom,_left,_right};
	}






switch (block.getType())	{
			case COIN:
				_uninteractive.add(new Coin(_gamespace, block.getBody().getX() + 3*Constants.BLOCK_LENGTH/8,
						block.getBody().getY() - Constants.BLOCK_LENGTH/2, Type.COIN));
				break;
			case MUSHROOM:
				item = new Mushroom(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.MUSHROOM);
				addNPCKeyFrame(item);
				break;
			case FLOWER:
				item = new Flower(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.FLOWER);
				addNPCKeyFrame(item);
				break;
			case STAR:
				item = new Star(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.STAR);
				addNPCKeyFrame(item);
				break;
			default:
				break;
			}
			
			
			
			
			
			
			
			
			for (Offensives attack : _offensives)	{
//				if (attack.getBody().intersects(_moving.getBody().getBoundsInLocal())
//						&& _moving.isEnemy()
//						&& (!_moving.isDead() || _moving.isRogue()))	{
//					_moving.deathAnimation(); 
//					attack.delete();
//					_offensives.remove(attack);
//					break;
//				}
//			}




private void newItem(Square block)	{
			//puts an item on the screen depending on what block was hit
//			Item item = null;
//			switch (block.getType())	{
//			case COIN:
//				_uninteractive.add(new Coin(_gamespace, block.getBody().getX() + 3*Constants.BLOCK_LENGTH/8,
//						block.getBody().getY() - Constants.BLOCK_LENGTH/2, Type.COIN));
//				break;
//			case MUSHROOM:
//				item = new Mushroom(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.MUSHROOM);
//				addNPCKeyFrame(item);
//				break;
//			case FLOWER:
//				item = new Flower(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.FLOWER);
//				addNPCKeyFrame(item);
//				break;
//			case STAR:
//				item = new Star(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.STAR);
//				addNPCKeyFrame(item);
//				break;
//			default:
//				break;
//			}
			
			if (block.getType() == Type.COIN) {
				_uninteractive.add(new Coin(_gamespace, block.getBody().getX() + 3*Constants.BLOCK_LENGTH/8,
						block.getBody().getY() - Constants.BLOCK_LENGTH/2, Type.COIN));
			}
			else	{
				Item item = new Star(_gamespace, block.getBody().getX(), block.getBody().getY(), block.getType());
				addNPCKeyFrame(item);
				_items.add(item);
			}
			
			_sky.toBack();
//			if (item!=null)	{
//				_items.add(item);
//			}
		}

SPECIAL TLS IN MARIO CLASS
//	@Override
//	public void setupTLs()	{
//		super.setupTLs();
//		
//		_grow = new Timeline();
//		_grow.setCycleCount(7);
//		_grow.getKeyFrames().add(new KeyFrame(Duration.seconds(0.2), "Grow", 
//				new EventHandler<ActionEvent>(){
//			private int _count = 1;
//			@Override
//	        public void handle(ActionEvent e) {
//				if (_count%2==1)	{	//look like big mario
//					_body.setHeight(2*Constants.BLOCK_LENGTH);
//					if (getJumpTL().getStatus() == Status.STOPPED)	{
//						_body.setY(_body.getY() - Constants.BLOCK_LENGTH);
//					}
//					setCostumes(Constants.BIG_MARIO);
//					_otherSet = Constants.BIG_DEAD_JUMP;
//				}
//				else	{	//look like little mario
//					_body.setHeight(Constants.BLOCK_LENGTH);
//					if (getJumpTL().getStatus() == Status.STOPPED)	{
//						_body.setY(_body.getY() + Constants.BLOCK_LENGTH);
//					}
//					setCostumes(Constants.MARIO);
//					_otherSet = Constants.DEAD_JUMP;
//				}
////				if (getCostNum() == 0)	{
////					setCostNum(1);
////				}
//				if (getJumpTL().getStatus() == Status.STOPPED)	{
//					_body.setFill(getSet()[getCostNum()/* - 1*/]);
//				}
//				else	{
//					_body.setFill(_otherSet[1]);
//				}
//				_count++;
//				
//				e.consume();
//	        }
//		}));
//		_grow.setOnFinished(new EventHandler<ActionEvent>(){
//			@Override
//	        public void handle(ActionEvent e) {
//				if (getJumpTL().getStatus() == Status.PAUSED) {
//					_body.setFill(_otherSet[1]);
//				}
//				else	{
//					_body.setFill(getSet()[0]);
//				}
//				e.consume();
//	        }
//		});
//		
//		_blinking = new Timeline();
//		_blinking.setCycleCount(8);
//		_blinking.getKeyFrames().add(new KeyFrame(Duration.seconds(0.2), "Blink", 
//				new EventHandler<ActionEvent>(){
//			@Override
//	        public void handle(ActionEvent e) {
//				if (_parent.getChildren().contains(_body))	{
//					_parent.getChildren().remove(_body);
//				}
//				else	{
//					_parent.getChildren().add(_body);
//				}
//				
//				e.consume();
//	        }
//		}));
//		_blinking.setOnFinished(new EventHandler<ActionEvent>(){
//			@Override
//	        public void handle(ActionEvent e) {
//				_isBlinking = false;
//				if (getJumpTL().getStatus() == Status.STOPPED) {
//					_body.setFill(Constants.MARIO1);
//				}
//				else	{
//					_body.setFill(Constants.JUMP);
//				}
//				e.consume();
//	        }
//		});
//	}

AFTER REHAUL
package Mario;

import java.util.ArrayList;

import javafx.animation.Animation;
import javafx.animation.Animation.Status;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

public class Game	{
	
	private int _colsDeleted;
	private int _count;
	private boolean _paused;
	private Mario _mario;
	private Square[][] _squaresOnScreen;
	private Square[][] _squaresOffScreen;
	private Type[][] _map;
	private Type[][] _offScreenMap;
	private ArrayList<Enemy> _enemies;
	private ArrayList<Item> _items;
	private ArrayList<Offensives> _offensives;
	private ArrayList<Pulsating> _pulsating;
	private ArrayList<Character> _uninteractive;
	private Timeline _pulsate;
	private Timeline _grow;
	private Timeline _blinking;
	private Line _horTestLine;
	private Line _vertTestLine;
	private Pane _gamespace;
	private Rectangle _sky;
	private boolean _slowFall;
	
	public Game(Pane gamespace, Rectangle bg, Pane visualize)	{
		_gamespace = gamespace;
		_sky = bg;
		_gamespace.addEventHandler(KeyEvent.KEY_PRESSED, new PressHandler());
		_gamespace.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>()	{
			@Override
			public void handle(KeyEvent event) {
				if (!_paused && !_mario.isDead())	{
					KeyCode keyPressed = event.getCode();
					switch (keyPressed)	{
					case LEFT:
						_mario.getMoveTL().stop();
						_mario.getAnimate().stop();
						if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
							_mario.startingSprite();
						}
						break;
					case RIGHT:
						_mario.getMoveTL().stop();
						_mario.getAnimate().stop();
						if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
							_mario.startingSprite();
						}
						break;
					case SPACE:
						double minHoldY = (Constants.BLOCKS_HIGH-6)*Constants.BLOCK_LENGTH;
						if (_mario.getVelocity() < 0)	{
							if (_mario.getBody().getY() > minHoldY) {
								_mario.setVelocity(
										-1*Math.pow(2*Constants.GRAVITY*(_mario.getBody().getY() - minHoldY), 0.5));	//kinematics equation
							}
							else	{
								_mario.setVelocity(0);
							}
						}
						break;
					default:
						break;
					}
				}
			}
		});
		this.setupGame();
	}
	
	private void setupGame()	{
		_mario = new Mario(_gamespace, Constants.BLOCKS_HIGH-3, 0);
		_mario.getAnimate().stop();
		this.setupTLs();
		this.setupMap();
		_mario.getBody().toFront();
//		_gamespace.getChildren().clear();
//		_gamespace.getChildren().add(_mario.getBody());
//		_mario.getBody().setY(0);
//		Goomba goomba = new Goomba(_gamespace, 11, 0);
//		goomba.getBody().toFront();
//		_enemies.add(goomba);
	}
	
	private void setupMap()	{ //make a new generation system where only blocks on screen are loaded
		Map temp = new Map();
		_enemies = new ArrayList<Enemy>();	//list of enemies on screen
		_items = new ArrayList<Item>();	//items on screen
		_offensives = new ArrayList<Offensives>();	//mario's attacks, e.g. fireballs
		_pulsating = new ArrayList<Pulsating>();	//things that pulsate on screen
		_uninteractive = new ArrayList<Character>();	//characters that the user doesn't interact with
		_squaresOnScreen = new Square[Constants.BLOCKS_HIGH][Constants.BLOCKS_WIDE];
		_squaresOffScreen = new Square[Constants.BLOCKS_HIGH][Constants.OFFSET];
		_map = temp.getMap();
		_offScreenMap = temp.getOffScreen();
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {	//generates the blocks initially on screen
			for (int j = 0 ; j < Constants.BLOCKS_WIDE; j++)	{ 
				_squaresOnScreen[i][j] = this.detNewPiece(i, j);
			}
		}
		Square piece = null;
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {	//generates the blocks initially off screen
			for (int j = 0 ; j < Constants.OFFSET; j++)	{	//offset is how many columns are off screen
				switch (_offScreenMap[i][j])	{
				case FREE:
					piece = new Square(_gamespace, i, j - Constants.OFFSET);
					break;
				case FLOOR:
					piece = new Floor(_gamespace, i, j - Constants.OFFSET);
					break;
				default:
					break;
				}
				_squaresOffScreen[i][j] = piece;
			}
		}
		_sky.toBack();
	}
	
	private Square detNewPiece(int i, int j)	{
		Square piece = null;
		Mystery mystery = null;
		switch (_map[i][j + _colsDeleted])	{
		case PIT:
		case FREE:
			piece = new Square(_gamespace, i, j);
			piece.getBody().toBack();
			break;
		case BIGHILL:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*5, Constants.BLOCK_LENGTH*2,
					Constants.BIG_HILL, Type.BIGHILL);
//			piece.getBody().toBack();
			break;
		case SMALLHILL:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*3, Constants.BLOCK_LENGTH,
					Constants.SMALL_HILL, Type.SMALLHILL);
//			piece.getBody().toBack();
			break;
		case BIGBUSH:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*5, Constants.BLOCK_LENGTH,
					Constants.BIG_BUSH, Type.BIGBUSH);
			piece.getBody().toBack();
			break;
		case MEDBUSH:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*4, Constants.BLOCK_LENGTH,
					Constants.MED_BUSH, Type.MEDBUSH);
//			piece.getBody().toBack();
			break;
		case SMALLBUSH:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*3, Constants.BLOCK_LENGTH,
					Constants.SMALL_BUSH, Type.SMALLBUSH);
//			piece.getBody().toBack();
			break;
		case GOOMBA_START:
			piece = new Square(_gamespace, i, j);
			Goomba goomba = new Goomba(_gamespace, i, j);
			this.addNPCKeyFrame(goomba);
			goomba.getMoveTL().play();
			_enemies.add(goomba);
			break;
		case KOOPA_START:
			piece = new Square(_gamespace, i, j);
			Koopa koopa = new Koopa(_gamespace, i, j);
			this.addNPCKeyFrame(koopa);
			koopa.getMoveTL().play();
			_enemies.add(koopa);
			break;
		case FLOOR:
			piece = new Floor(_gamespace, i, j);
			break;
		case BRICK:
			piece = new Brick(_gamespace, i, j);
			break;
		case PIPE_TL:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_TL);
			break;
		case PIPE_TR:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_TR);
			break;
		case PIPE_L:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_L);
			break;
		case PIPE_R:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_R);
			break;
		case STAIR:
			piece = new Stair(_gamespace, i, j);
			break;
		case COIN_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.COIN);
			piece.getBody().setFill(Constants.MYSTERY_SET[_count]);
			mystery = (Mystery) piece;
			_pulsating.add(mystery);
			break;
		case MUSHROOM_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.MUSHROOM);
			piece.getBody().setFill(Constants.MYSTERY_SET[_count]);
			mystery = (Mystery) piece;
			_pulsating.add(mystery);
			break;
		case FLOWER_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.FLOWER);
			piece.getBody().setFill(Constants.MYSTERY_SET[_count]);
			mystery = (Mystery) piece;
			_pulsating.add(mystery);
			break;
		case STAR_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.STAR);
			piece.getBody().setFill(Constants.MYSTERY_SET[_count]);
			mystery = (Mystery) piece;
			_pulsating.add(mystery);
			break;
		default:
			break;
		}
		return piece;
	}
	
	private void addNPCKeyFrame(Character npc)	{
		KeyFrame jump = new KeyFrame(Duration.seconds(Constants.DURATION), new NPCJump(npc));
		npc.getJumpTL().getKeyFrames().add(jump);
		
		KeyFrame move = new KeyFrame(Duration.seconds(Constants.DURATION), new NPCMove(npc));
		npc.getMoveTL().getKeyFrames().add(move);
	}

	private void setupTLs()	{
		KeyFrame jump = new KeyFrame(Duration.seconds(Constants.DURATION), new MVM(_mario));
		_mario.getJumpTL().getKeyFrames().add(jump);
		
		KeyFrame move = new KeyFrame(Duration.seconds(Constants.DURATION/4/*5*/), new MHM(_mario));
		_mario.getMoveTL().getKeyFrames().add(move);
		
		_grow = new Timeline();
		_grow.setCycleCount(7);
		_grow.getKeyFrames().add(new KeyFrame(Duration.seconds(0.2), "Grow", 
				new EventHandler<ActionEvent>(){
			
		}));
		_grow.setOnFinished(new EventHandler<ActionEvent>(){
			@Override
	        public void handle(ActionEvent e) {
				if (getJumpTL().getStatus() == Status.PAUSED) {
					_body.setFill(_otherSet[1]);
				}
				else	{
					_body.setFill(getSet()[0]);
				}
				e.consume();
	        }
		});
		
		_blinking = new Timeline();
		_blinking.setCycleCount(8);
		_blinking.getKeyFrames().add(new KeyFrame(Duration.seconds(0.2), "Blink", 
				new EventHandler<ActionEvent>(){
			@Override
	        public void handle(ActionEvent e) {
				if (_parent.getChildren().contains(_body))	{
					_parent.getChildren().remove(_body);
				}
				else	{
					_parent.getChildren().add(_body);
				}
				
				e.consume();
	        }
		}));
		_blinking.setOnFinished(new EventHandler<ActionEvent>(){
			@Override
	        public void handle(ActionEvent e) {
				_isBlinking = false;
				if (getJumpTL().getStatus() == Status.STOPPED) {
					_body.setFill(Constants.MARIO1);
				}
				else	{
					_body.setFill(Constants.JUMP);
				}
				e.consume();
	        }
		});
		
		_pulsate = new Timeline();
		_pulsate.getKeyFrames().add(new KeyFrame(Duration.seconds(0.4), new Pulsate()));
		_pulsate.setCycleCount(Animation.INDEFINITE);
		_pulsate.play();

		_horTestLine = new Line(0,0,0,0);
		_vertTestLine = new Line(0,0,0,0);
	}
	
	public void pauseAll()	{
		_mario.pauseAll();
		for (Enemy enemy : _enemies) {
			enemy.pauseAll();
		}
		for (Item item : _items) {
			item.pauseAll();
		}
		for (Offensives attack : _offensives) {
			attack.pauseAll();
		}
		for (Character character : _uninteractive) {
			character.pauseAll();
		}
		_paused = true;
	}
	
	public void playAll()	{
		_mario.playAll();
		for (Enemy enemy : _enemies) {
			enemy.playAll();
		}
		for (Item item : _items) {
			item.playAll();
		}
		for (Offensives attack : _offensives) {
			attack.playAll();
		}
		for (Character character : _uninteractive) {
			character.playAll();
		}
		_paused = false;
	}
	
	private Square nextBlock(double newX, double newY, Character character, boolean forJump)	{
		Line test = null;
		if (forJump) {
			_horTestLine.setStartX(character.getBody().getX() + 5);
			_horTestLine.setEndX(character.getBody().getX() + character.getBody().getWidth() - 5);
			_horTestLine.setStartY(newY);
			_horTestLine.setEndY(newY);
			test = _horTestLine;
		}
		else	{
			int weight = 0;
			if (character.getDir() == Direction.RIGHT) {
				weight = 1;
			}
			_vertTestLine.setStartX(newX + character.getBody().getWidth()*weight);
			_vertTestLine.setEndX(newX + character.getBody().getWidth()*weight);
			_vertTestLine.setStartY(character.getBody().getY() + 5);
			_vertTestLine.setEndY(character.getBody().getY() + character.getBody().getHeight() - 5);
			test = _vertTestLine;
		}
		for (Square[] squares : _squaresOnScreen)	{
			for (Square square : squares)	{
				if (square.getBody().intersects(test.getBoundsInLocal())
						&& !square.isFree()) {
					return square;
				}
			}
		}
		return null;
	}

	private class PressHandler implements EventHandler<KeyEvent>	{
		
		public PressHandler()	{}
		
		@Override
		public void handle(KeyEvent event)	{
			if (!_paused && !_mario.isDead())	{
				KeyCode keyPressed = event.getCode();
				switch (keyPressed)	{
				case LEFT:
					_mario.setDir(Direction.LEFT);
					_mario.getBody().setRotate(180);
					if (_mario.getMoveTL().getStatus() != Status.RUNNING)	{
						_mario.getMoveTL().play();
						if (_mario.getAnimate().getStatus() != Status.RUNNING)	{
							_mario.switchCostume();
							_mario.getAnimate().play();
						}
					}
					break;
				case RIGHT:
					_mario.setDir(Direction.RIGHT);
					_mario.getBody().setRotate(0);
					if (_mario.getMoveTL().getStatus() != Status.RUNNING)	{
						_mario.getMoveTL().play();
						if (_mario.getAnimate().getStatus() != Status.RUNNING)	{
							_mario.switchCostume();
							_mario.getAnimate().play();
						}
					}
					break;
				case SPACE:
					if (_mario.getJumpTL().getStatus() == Status.STOPPED/*RUNNING*/) {
						_mario.getBody().setFill(_mario.getDeadJump()[1]);
						_mario.getAnimate().pause();
						_mario.setVelocity(Constants.INIT_V);
						_mario.getJumpTL().play();
					}
//					if (_mario.getVelocity() < 0 /*-600*/
//							&& _mario.getVelocity() > Constants.INIT_V*5/6) {
//						_mario.setVelocity(0);
//					}
					break;
				case DOWN:
					break;
				case S:
					_mario.getJumpTL().getKeyFrames().clear();
					if (_slowFall)	{
						_slowFall = false;
						_mario.getJumpTL().getKeyFrames().add(new KeyFrame(Duration.seconds(Constants.DURATION), new MVM(_mario)));
					}
					else	{
						_slowFall = true;
						_mario.getJumpTL().getKeyFrames().add(new KeyFrame(Duration.seconds(Constants.DURATION*5), new MVM(_mario)));
					}
					break;
				case H:
					if (_mario.getBody().getFill() == Color.RED)	{
						_mario.getBody().setFill(Constants.MARIO1);
					}
					else	{
						_mario.getBody().setFill(Color.RED);
						_mario.getAnimate().stop();
					}
					break;
				case E:
					System.out.println(_enemies.size());
					break;
				case Q:
					Platform.exit();
					break;
				case F:
					Fireball fireball = new Fireball(_gamespace,_mario.getBody().getX() + _mario.getBody().getWidth(), _mario.getBody().getY());
					_offensives.add(fireball);	//arguments are position, not coordinates
					addNPCKeyFrame(fireball);
					fireball.getMoveTL().play();
					break;
				default:
					break;
				}
			}
			
			event.consume();
		}
	}
	//make pause and stop all the same
	
	private class MVM implements EventHandler<ActionEvent>	{

		private ArrayList<Enemy> _removeable;
		private Character _jumpMario;
		private Object _LOCK = new Object();
		Rectangle _foot;
		Rectangle _enemyHead;
		
		public MVM(Character mario)	{
			_jumpMario = mario;
			_jumpMario.setVelocity(Constants.INIT_V);
			_removeable = new ArrayList<Enemy>();
			_foot = new Rectangle(_jumpMario.getBody().getX(),0,_jumpMario.getBody().getWidth(),_jumpMario.getBody().getHeight()/4);
			_enemyHead = new Rectangle(0,0,0,0);//null;
			_foot.setFill(Color.RED);
		}
		
		@Override
        public void handle(ActionEvent e) {
			
			_gamespace.getChildren().removeAll(_enemyHead,_foot);
			
			_jumpMario.updateVelocity();
			Rectangle body = _jumpMario.getBody();
			double newY = body.getY() + _jumpMario.getVelocity() * Constants.DURATION;
			Square nextBlock = null;
//			Line foot = new Line(body.getX(), body.getY() + body.getHeight(), 
//					body.getX() + body.getHeight(), body.getY() + body.getHeight());
//			_foot = new Rectangle(_jumpMario.getBody().getX(),0,_jumpMario.getBody().getWidth(),_jumpMario.getBody().getHeight()/4);
//			_enemyHead = null;
			
			if (_jumpMario.isDead())	{
				body.setY(newY);
			}
			else if (_jumpMario.getVelocity() > 0)	{
				nextBlock = nextBlock(body.getX(), newY + body.getHeight(), _jumpMario, true);//nextBlockForJump(newY + body.getHeight(), _jumping);
				if (nextBlock != null && !_jumpMario.isDead())	{	//when it lands
					body.setY(nextBlock.getBody().getY() - body.getHeight() - 1);
					_jumpMario.onHittingGround();
				}
				else	{ 
					body.setY(newY);
				}
				
				for (Enemy enemy : _enemies)	{	//checks to see if mario is jumping on an enemy
					_enemyHead = new Rectangle(enemy.getBody().getX(), enemy.getBody().getY(), 
							enemy.getBody().getWidth(), enemy.getBody().getHeight()/2);
//					_foot.setY(_jumpMario.getBody().getY()+_mario.getBody().getHeight()*3/4);
					if (_enemyHead.intersects(_foot.getBoundsInLocal())
							&& !enemy.isDead())	{
						_jumpMario.setVelocity(Constants.INIT_V);
						this.detEnemyAction(enemy);
						System.out.println("boop");
						break;	//patch
					}
				}
			}	
			else if (_jumpMario.getVelocity() <= 0)	{
				nextBlock = nextBlock(body.getX(), newY, _jumpMario, true);//nextBlockForJump(newY, _jumping);
				if (nextBlock != null)	{
					_jumpMario.setVelocity(_jumpMario.getVelocity()*-1);
					body.setY(nextBlock.getBody().getY() + nextBlock.getBody().getHeight() + 1);
					this.detBlockAction(nextBlock);
				}
				body.setY(newY);
			}
			
			if (body.getY() > Constants.MAX_Y)	{
				Platform.exit();
			}
			
			_foot.setX(_mario.getBody().getX());
			_foot.setY(_jumpMario.getBody().getY()+_mario.getBody().getHeight()*3/4);
			_gamespace.getChildren().addAll(_enemyHead,_foot);
			
			_enemies.removeAll(_removeable);
			_removeable.clear();
			
			e.consume();
        }
		
		@SuppressWarnings("unlikely-arg-type")
		private void detBlockAction(Square block)	{
			if (!block.isImpacted())	{
				switch (block.getType())	{
				case BRICK:
					if (_mario.isBig() && block.getBop().getStatus() != Status.RUNNING)	{
						block.delete();
					}
					else	{
						block.getBop().play();
					}
					break;
				case COIN:
				case MUSHROOM:
				case FLOWER:
				case STAR:
					this.newItem(block);
					block.delete();
					_pulsating.remove(block);
					break;
				default:
					break;
				}
				for (Enemy enemy : _enemies)	{ //kills enemies if block under them is hit
					Line enemyFoot = new Line(block.getBody().getX(), block.getBody().getY() - 1, 
							block.getBody().getX() + enemy.getBody().getHeight(), block.getBody().getY() - 1);
					if (enemy.getBody().intersects(enemyFoot.getBoundsInLocal())) {
						if (enemy.getType() == Type.KOOPA) {
							enemy.getBody().setRotationAxis(Rotate.X_AXIS);
							enemy.getBody().setRotate(180);
							enemy.setVelocity(-200);
							enemy.getJumpTL().play();
							enemy.rogueAction(Direction.NONE);
						}
						else	{
							enemy.deathAnimation();
						}
					}
				}
			}
		}
		
		private void newItem(Square block)	{
			//puts an item on the screen depending on what block was hit
			Item item = null;
			switch (block.getType())	{
			case COIN:
				/*item = */_uninteractive.add(new Coin(_gamespace, block.getBody().getX() + 3*Constants.BLOCK_LENGTH/8,
						block.getBody().getY() - Constants.BLOCK_LENGTH/2, Type.COIN));
//				addNPCKeyFrame(item);
				break;
			case MUSHROOM:
				item = new Mushroom(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.MUSHROOM);
				addNPCKeyFrame(item);
				break;
			case FLOWER:
				item = new Flower(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.FLOWER);
				addNPCKeyFrame(item);
				break;
			case STAR:
				item = new Star(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.STAR);
				addNPCKeyFrame(item);
				break;
			default:
				break;
			}
			_sky.toBack();
			if (item!=null)	{
				_items.add(item);
			}
		}
		
		private void detEnemyAction(Enemy enemy)	{
			//initiates an enemy's reponse to being jumped on
			switch (enemy.getType())	{
			case GOOMBA:
				enemy.delete();
//				Thread.sleep(300);
//				synchronized (_LOCK) {
//				        _LOCK.wait();
//				    }
				_gamespace.getChildren().remove(enemy.getBody());
				_enemies.remove(enemy);
				break;
			case KOOPA:
				Direction dir = Direction.NONE;
				if (_jumpMario.getBody().getX() < enemy.getBody().getX() + 11*_jumpMario.getBody().getWidth()/24)	{
					dir = Direction.RIGHT;
				}
				else if (_jumpMario.getBody().getX() + _jumpMario.getBody().getWidth() > enemy.getBody().getX() + 13*_jumpMario.getBody().getWidth()/24)	{
					dir = Direction.LEFT;
				}
				enemy.rogueAction(dir);
				//if mario touches the bottom half he dies
				break;
			default:
				break;
			}
		}
		
	}
	
	private class MHM implements EventHandler<ActionEvent>	{

		private Mario _marioMoving;
		private Object _LOCK = new Object();
		
		public MHM(Mario mario)	{
			_marioMoving = mario;
		}
	
		@Override
        public void handle(ActionEvent e) {
			double displacement = _marioMoving.getDir().direction()*Constants.DISPLACEMENT*_marioMoving.getSpeedWeight();
			Rectangle body = _marioMoving.getBody();
			double newX = body.getX() + displacement;
			Rectangle deathZone = null;
			
			if (_marioMoving.isDead()) {	//prioritizes falling to the bottom of the screen if dead
				body.setX(newX);
			}
			else if (nextBlock(body.getX(), body.getY() + 1 + body.getHeight(), _marioMoving, true)/*nextBlockForJump(body.getY() + 1 + body.getHeight(), _moving)*/ == null
					&& _marioMoving.getJumpTL().getStatus() == Status.STOPPED)	{	//acts a gravity simulation
				_marioMoving.fall();
			}
			else if (/*nextBlockForMove(newX, _moving)*/nextBlock(newX, body.getY(), _marioMoving, false) == null
					&& !nextToNPC())	{ //if mario is moving to a free block
				if (newX >= Constants.MAX_X
						&& _colsDeleted < Constants.TOT_BLOCKS_WIDE - Constants.BLOCKS_WIDE) {	//if mario is at scrolling distance and the end of the level is not reached
					this.adjustSquares();
					this.checkScroll();
				}
				_marioMoving.move(displacement);
			}
			
			for (Enemy enemy : _enemies)	{
				deathZone = new Rectangle(enemy.getBody().getX(), enemy.getBody().getY() + 3*enemy.getBody().getHeight()/4, 
						enemy.getBody().getHeight(), enemy.getBody().getHeight()/4);
				if (_marioMoving.getBody().intersects(deathZone.getBoundsInLocal()) && !_marioMoving.isDead() 
						&& !_marioMoving.getBlinking() && !enemy.isDead())	{
					_gamespace.getChildren().add(deathZone);
//					pauseAll();
					_mario.die();
				}
				else if (_marioMoving.getBody().intersects(enemy.getBody().getBoundsInLocal())
						&& enemy.isRogue()
//						&& _mario.getJumpTL().getStatus() != Status.RUNNING
						&& enemy.getMoveTL().getStatus() == Status.PAUSED)	{
					enemy.getBody().setX(enemy.getBody().getX() + 10*Constants.DISPLACEMENT*_mario.getSpeedWeight()*_mario.getDir().direction());
					enemy.rogueAction(_mario.getDir());
				}
			}
			for (Item item : _items)	{
				if (_marioMoving.getBody().intersects(item.getBody().getBoundsInLocal()))	{
					this.initEffect(item);
				}
			}
			
			e.consume();
        }
		
		private void checkScroll()	{
			if (_squaresOnScreen[0][0].getBody().getX() <= -1 * Constants.BLOCK_LENGTH) {
				this.shiftArrays();
				_mario.getBody().toFront();
				if (_colsDeleted != Constants.TOT_BLOCKS_WIDE + Constants.BLOCKS_WIDE)	{
					_colsDeleted++;
				}
			}
		}
		
		private void shiftArrays()	{
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++)	{	//moves columns of array one space to the left
				for (int j = 1 ; j < Constants.OFFSET; j++)	{
					_squaresOffScreen[i][j-1] = _squaresOffScreen[i][j];
				}
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++)	{	//moves the leftmost column of onscreen to rightmost of offscreen
				_squaresOffScreen[i][Constants.OFFSET-1] = _squaresOnScreen[i][0];
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH; i++)	{	//moves columns of array one space to the left
				for (int j = 1 ; j < Constants.BLOCKS_WIDE; j++)	{
					_squaresOnScreen[i][j-1] = _squaresOnScreen[i][j];
				}
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {	//generate new squares, going down the column
				_squaresOnScreen[i][Constants.BLOCKS_WIDE-1] = 
						detNewPiece(i, Constants.BLOCKS_WIDE-1);
			}
		}
		
		private void adjustSquares()	{
			for (Square[] pieces : _squaresOffScreen)	{
				for (Square piece : pieces)	{
					piece.getBody().setX(piece.getBody().getX() - Constants.DISPLACEMENT*_mario.getSpeedWeight());
					if (piece.getBody().getX() < -1 * piece.getBody().getWidth() - Constants.OFFSET*Constants.BLOCK_LENGTH)	{
						piece.delete();
					}
				}
			}
			for (Square[] squares : _squaresOnScreen)	{
				for (Square square : squares)	{
					square.getBody().setX(square.getBody().getX() - Constants.DISPLACEMENT*_mario.getSpeedWeight());
				}
			}
			for (Enemy enemy : _enemies) {
				enemy.getBody().setX(enemy.getBody().getX() - Constants.DISPLACEMENT*_mario.getSpeedWeight());
				if (enemy.getBody().getX() < -1 * Constants.OFFSET*Constants.BLOCK_LENGTH)	{
					_enemies.remove(enemy);
					enemy = null;
					break;
				}
			}
			ArrayList<Character> entities = new ArrayList<Character>();
			ArrayList<Character> removeable = new ArrayList<Character>();
			entities.addAll(_items);	entities.addAll(_offensives);	entities.addAll(_uninteractive);
			for (Character entity : entities) {
				entity.getBody().setX(entity.getBody().getX() - Constants.DISPLACEMENT*_mario.getSpeedWeight());
				if (entity.getBody().getX() < -Constants.OFFSET*Constants.BLOCK_LENGTH)	{
					removeable.add(entity);
				}
			}
			_items.removeAll(removeable);	_offensives.removeAll(removeable);	_uninteractive.removeAll(removeable);
		}
		
		private void initEffect(Item item)	{
			switch (item.getType())	{
			case MUSHROOM:
				pauseAll();
				_mario.grow();
				break;
			case FLOWER:
				_mario.transform();
				break;
			case STAR:
				_mario.invincible();
				break;
			default:
				break;
			}
			_gamespace.getChildren().remove(item.getBody());
			pauseAll();
			_items.remove(item);
//			Thread.sleep(1400);
//			synchronized (_LOCK) {
//			        _LOCK.wait(1400);
//			    }
			playAll();
		}
		
		private boolean nextToNPC()	{
			Rectangle body = _marioMoving.getBody();
			double weight = 0;
			if (_marioMoving.getDir() == Direction.RIGHT) {
				weight = body.getWidth();
			}
			_vertTestLine.setStartX(body.getX() + weight);
			_vertTestLine.setEndX(body.getX() + weight);
			_vertTestLine.setStartY(body.getY());
			_vertTestLine.setEndY(body.getY() + body.getHeight());
			for (Enemy enemy : _enemies)	{
				if (enemy.getBody().intersects(_vertTestLine.getBoundsInLocal()))	{
					return true;
				}
			}
			for (Item item : _items)	{
				if (item.getBody().intersects(_vertTestLine.getBoundsInLocal()))	{
					return true;
				}
			}
			for (Offensives attack : _offensives)	{
				if (attack.getBody().intersects(_vertTestLine.getBoundsInLocal()))	{
					return true;
				}
			}
			return false;
		}
	}
	
	private class NPCJump implements EventHandler<ActionEvent>	{

		private ArrayList<Enemy> _removeable;
		private Character _jumping;
		
		public NPCJump(Character jumping)	{
			_jumping = jumping;
			_jumping.setVelocity(Constants.INIT_V);
			_removeable = new ArrayList<Enemy>();
		}
		
		@SuppressWarnings("unlikely-arg-type")
		@Override
        public void handle(ActionEvent e) {
			_jumping.updateVelocity();
			Rectangle body = _jumping.getBody();
			double newY = body.getY() + _jumping.getVelocity() * Constants.DURATION;
			Square nextBlock = null;
			
			if (_jumping.isDead())	{
				body.setY(newY);
			}
			else if (_jumping.getVelocity() > 0)	{
				nextBlock = nextBlock(body.getX(), newY + body.getHeight(), _jumping, true);//nextBlockForJump(newY + body.getHeight(), _jumping);
				if (nextBlock != null && !_jumping.isDead())	{	//when it lands
					body.setY(nextBlock.getBody().getY() - body.getHeight() - 1);
					_jumping.onHittingGround();
				}
				else	{ 
					body.setY(newY);
				}
			}	
			else if (_jumping.getVelocity() <= 0)	{
				nextBlock = nextBlock(body.getX(), newY, _jumping, true);//nextBlockForJump(newY, _jumping);
				if (nextBlock != null)	{
					_jumping.setVelocity(_jumping.getVelocity()*-1);
					body.setY(nextBlock.getBody().getY() + nextBlock.getBody().getHeight() + 1);
				}
				body.setY(newY);
			}
			
			if (body.getY() > Constants.MAX_Y)	{
				_enemies.remove(_jumping);	_items.remove(_jumping);	_offensives.remove(_jumping);	_uninteractive.remove(_jumping);
				_gamespace.getChildren().remove(body);
				_jumping.pauseAll();
			}
			
			_enemies.removeAll(_removeable);
			_removeable.clear();
			
			e.consume();
        }
		
	}
	
	private class NPCMove implements EventHandler<ActionEvent>	{

		private Character _moving;
		
		public NPCMove(Character npc)	{
			_moving = npc;
		}
	
		@Override
        public void handle(ActionEvent e) {
			double displacement = _moving.getDir().direction()*Constants.DISPLACEMENT*_moving.getSpeedWeight();
			Rectangle body = _moving.getBody();
			double newX = body.getX() + displacement;
			Rectangle deathZone = new Rectangle(body.getX(), body.getY() + 3*body.getHeight()/4, 
					body.getHeight(), body.getHeight()/4);
			
			if (_mario.getBody().intersects(deathZone.getBoundsInLocal()) && !_mario.isDead() && !_mario.getBlinking()
					& !_moving.isDead() && _moving.isEnemy())	{
//				pauseAll();
//				deathZone.setFill(Color.PURPLE);
//				_gamespace.getChildren().add(deathZone);
				_mario.die();
			}
			else if (_moving.getBody().intersects(_mario.getBody().getBoundsInLocal())
					&& _moving.isNPC() && !_moving.isEnemy())	{
				this.initEffect();
			}
			if (_moving.isDead()) {
				body.setX(newX);
			}
			else if (nextBlock(body.getX(), body.getY() + 1 + body.getHeight(), _moving, true)/*nextBlockForJump(body.getY() + 1 + body.getHeight(), _moving)*/ == null
					&& _moving.getJumpTL().getStatus() == Status.STOPPED)	{
				_moving.fall();
			}
			else if (nextBlock(newX, body.getY(), _moving, false) == null
					&& (!nextToNPC() || _moving.isRogue()))	{ //if mario is moving to a free block
				_moving.move(displacement);
			}
			else if (!_moving.isDead())	{
				_moving.flip();
			}


			
			e.consume();
        }
		
		private void initEffect()	{
			switch (_moving.getType())	{
			case MUSHROOM:
				pauseAll();
				_mario.grow();
				break;
			case FLOWER:
				_mario.transform();
				break;
			case STAR:
				_mario.invincible();
				break;
			default:
				break;
			}
			_gamespace.getChildren().remove(_moving.getBody());
			_moving.pauseAll();
			_items.remove(_moving);
//			Thread.sleep(1400);
//			synchronized (_LOCK) {
//			        _LOCK.wait(1400);
//			    }
			playAll();
		}
		
		private boolean nextToNPC()	{
			Rectangle body = _moving.getBody();
			double weight = 0;
			if (_moving.getDir() == Direction.RIGHT) {
				weight = body.getWidth();
			}
			_vertTestLine.setStartX(body.getX() + weight);
			_vertTestLine.setEndX(body.getX() + weight);
			_vertTestLine.setStartY(body.getY());
			_vertTestLine.setEndY(body.getY() + body.getHeight());
			for (Enemy enemy : _enemies)	{
				if (enemy.getBody().intersects(_vertTestLine.getBoundsInLocal())
						&& !enemy.getBody().equals(body))	{
					if (_moving.isRogue() && !enemy.isDead())	{
						enemy.deathAnimation(); 
					}
					return true;
				}
			}
			for (Item item : _items)	{
				if (item.getBody().intersects(_vertTestLine.getBoundsInLocal())
						&& !item.getBody().equals(body))	{
					return true;
				}
			}
			return false;
		}
	}
	
	private class Pulsate implements EventHandler<ActionEvent>	{

		@Override
		public void handle(ActionEvent event) {
			if (!_pulsating.isEmpty())	{
				for (Pulsating pulsable : _pulsating)	{
					pulsable.pulsate(_count);
				}
				if (_count == Constants.MYSTERY_SET.length-1)	{
					_count = 0;
				}
				else	{
					_count++;
				}
			}
		}
		
	}
	
	private class Grow implements EventHandler<ActionEvent>	{

		private int _count = 1;
		@Override
        public void handle(ActionEvent e) {
			Rectangle body = _mario.getBody();
			if (_count%2==1)	{	//look like big mario
				body.setHeight(2*Constants.BLOCK_LENGTH);
				if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
					body.setY(body.getY() - Constants.BLOCK_LENGTH);
				}
				setCostumes(Constants.BIG_MARIO);
				_otherSet = Constants.BIG_DEAD_JUMP;
			}
			else	{	//look like little mario
				body.setHeight(Constants.BLOCK_LENGTH);
				if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
					body.setY(body.getY() + Constants.BLOCK_LENGTH);
				}
				setCostumes(Constants.MARIO);
				_otherSet = Constants.DEAD_JUMP;
			}
//			if (getCostNum() == 0)	{
//				setCostNum(1);
//			}
			if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
				body.setFill(_mario.getSet()[_mario.getCostNum()/* - 1*/]);
			}
			else	{
				body.setFill(_otherSet[1]);
			}
			_count++;
			
			e.consume();
        }
		
	}
	
	private class Blink implements EventHandler<ActionEvent>	{

		@Override
		public void handle(ActionEvent event) {
			if (!_pulsating.isEmpty())	{
				for (Pulsating pulsable : _pulsating)	{
					pulsable.pulsate(_count);
				}
				if (_count == Constants.MYSTERY_SET.length-1)	{
					_count = 0;
				}
				else	{
					_count++;
				}
			}
		}
		
	}
	
}







COMBNINED MOVE AND JUMP
package Mario;

import java.util.ArrayList;

import javafx.animation.Animation;
import javafx.animation.Animation.Status;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

public class Game	{
	
	private int _colsDeleted;
	private int _count;
	private boolean _paused;
	private Mario _mario;
	private Square[][] _squaresOnScreen;
	private Square[][] _squaresOffScreen;
	private Type[][] _map;
	private Type[][] _offScreenMap;
	private ArrayList<Enemy> _enemies;
	private ArrayList<Item> _items;
	private ArrayList<Offensives> _offensives;
	private ArrayList<Pulsating> _pulsating;
	private ArrayList<Character> _uninteractive;
	private Timeline _pulsate;
	private Line _horTestLine;
	private Line _vertTestLine;
	private Pane _gamespace;
	private Rectangle _sky;
	
	public Game(Pane gamespace, Rectangle bg, Pane visualize)	{
		_gamespace = gamespace;
		_sky = bg;
		_gamespace.addEventHandler(KeyEvent.KEY_PRESSED, new PressHandler());
		_gamespace.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>()	{
			@Override
			public void handle(KeyEvent event) {
				if (!_paused && !_mario.isDead())	{
					KeyCode keyPressed = event.getCode();
					switch (keyPressed)	{
					case LEFT:
						_mario.getMoveTL().stop();
						_mario.getAnimate().stop();
						if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
							_mario.startingSprite();
						}
						break;
					case RIGHT:
						_mario.getMoveTL().stop();
						_mario.getAnimate().stop();
						if (_mario.getJumpTL().getStatus() == Status.STOPPED)	{
							_mario.startingSprite();
						}
						break;
					case SPACE:
						double minHoldY = (Constants.BLOCKS_HIGH-6)*Constants.BLOCK_LENGTH;
						if (_mario.getVelocity() < 0)	{
							if (_mario.getBody().getY() > minHoldY) {
								_mario.setVelocity(
										-1*Math.pow(2*Constants.GRAVITY*(_mario.getBody().getY() - minHoldY), 0.5));	//kinematics equation
							}
							else	{
								_mario.setVelocity(0);
							}
						}
						break;
					default:
						break;
					}
				}
			}
		});
		this.setupGame();
	}
	
	private void setupGame()	{
		_mario = new Mario(_gamespace, Constants.BLOCKS_HIGH-3, 0);
		_mario.getAnimate().stop();
		this.setupTLs();
		this.setupMap();
		_mario.getBody().toFront();
	}
	
	private void setupMap()	{ //make a new generation system where only blocks on screen are loaded
		Map temp = new Map();
		_enemies = new ArrayList<Enemy>();	//list of enemies on screen
		_items = new ArrayList<Item>();	//items on screen
		_offensives = new ArrayList<Offensives>();	//mario's attacks, e.g. fireballs
		_pulsating = new ArrayList<Pulsating>();	//things that pulsate on screen
		_uninteractive = new ArrayList<Character>();	//characters that the user doesn't interact with
		_squaresOnScreen = new Square[Constants.BLOCKS_HIGH][Constants.BLOCKS_WIDE];
		_squaresOffScreen = new Square[Constants.BLOCKS_HIGH][Constants.OFFSET];
		_map = temp.getMap();
		_offScreenMap = temp.getOffScreen();
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {	//generates the blocks initially on screen
			for (int j = 0 ; j < Constants.BLOCKS_WIDE; j++)	{ 
				_squaresOnScreen[i][j] = this.detNewPiece(i, j);
			}
		}
		Square piece = null;
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {	//generates the blocks initially off screen
			for (int j = 0 ; j < Constants.OFFSET; j++)	{	//offset is how many columns are off screen
				switch (_offScreenMap[i][j])	{
				case FREE:
					piece = new Square(_gamespace, i, j - Constants.OFFSET);
					break;
				case FLOOR:
					piece = new Floor(_gamespace, i, j - Constants.OFFSET);
					break;
				default:
					break;
				}
				_squaresOffScreen[i][j] = piece;
			}
		}
		_sky.toBack();
	}
	
	private Square detNewPiece(int i, int j)	{
		Square piece = null;
		Mystery mystery = null;
		switch (_map[i][j + _colsDeleted])	{
		case PIT:
		case FREE:
			piece = new Square(_gamespace, i, j);
			piece.getBody().toBack();
			break;
		case BIGHILL:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*5, Constants.BLOCK_LENGTH*2,
					Constants.BIG_HILL, Type.BIGHILL);
//			piece.getBody().toBack();
			break;
		case SMALLHILL:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*3, Constants.BLOCK_LENGTH,
					Constants.SMALL_HILL, Type.SMALLHILL);
//			piece.getBody().toBack();
			break;
		case BIGBUSH:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*5, Constants.BLOCK_LENGTH,
					Constants.BIG_BUSH, Type.BIGBUSH);
			piece.getBody().toBack();
			break;
		case MEDBUSH:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*4, Constants.BLOCK_LENGTH,
					Constants.MED_BUSH, Type.MEDBUSH);
//			piece.getBody().toBack();
			break;
		case SMALLBUSH:
			piece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*3, Constants.BLOCK_LENGTH,
					Constants.SMALL_BUSH, Type.SMALLBUSH);
//			piece.getBody().toBack();
			break;
		case GOOMBA_START:
			piece = new Square(_gamespace, i, j);
			Goomba goomba = new Goomba(_gamespace, i, j);
			this.addNPCKeyFrame(goomba);
			goomba.getMoveTL().play();
			_enemies.add(goomba);
			break;
		case KOOPA_START:
			piece = new Square(_gamespace, i, j);
			Koopa koopa = new Koopa(_gamespace, i, j);
			this.addNPCKeyFrame(koopa);
			koopa.getMoveTL().play();
			_enemies.add(koopa);
			break;
		case FLOOR:
			piece = new Floor(_gamespace, i, j);
			break;
		case BRICK:
			piece = new Brick(_gamespace, i, j);
			break;
		case PIPE_TL:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_TL);
			break;
		case PIPE_TR:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_TR);
			break;
		case PIPE_L:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_L);
			break;
		case PIPE_R:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_R);
			break;
		case STAIR:
			piece = new Stair(_gamespace, i, j);
			break;
		case COIN_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.COIN);
			piece.getBody().setFill(Constants.MYSTERY_SET[_count]);
			mystery = (Mystery) piece;
			_pulsating.add(mystery);
			break;
		case MUSHROOM_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.MUSHROOM);
			piece.getBody().setFill(Constants.MYSTERY_SET[_count]);
			mystery = (Mystery) piece;
			_pulsating.add(mystery);
			break;
		case FLOWER_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.FLOWER);
			piece.getBody().setFill(Constants.MYSTERY_SET[_count]);
			mystery = (Mystery) piece;
			_pulsating.add(mystery);
			break;
		case STAR_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.STAR);
			piece.getBody().setFill(Constants.MYSTERY_SET[_count]);
			mystery = (Mystery) piece;
			_pulsating.add(mystery);
			break;
		default:
			break;
		}
		return piece;
	}
	
	private void addNPCKeyFrame(Character npc)	{
		KeyFrame jump = new KeyFrame(Duration.seconds(Constants.DURATION), new Jump(npc));
		npc.getJumpTL().getKeyFrames().add(jump);
		
		KeyFrame move = new KeyFrame(Duration.seconds(Constants.DURATION), new Move(npc));
		npc.getMoveTL().getKeyFrames().add(move);
	}
	
	private void setupTLs()	{
		KeyFrame jump = new KeyFrame(Duration.seconds(Constants.DURATION), new Jump(_mario));
		_mario.getJumpTL().getKeyFrames().add(jump);
		
		KeyFrame move = new KeyFrame(Duration.seconds(Constants.DURATION/4/*5*/), new Move(_mario));
		_mario.getMoveTL().getKeyFrames().add(move);
		
		_pulsate = new Timeline();
		_pulsate.getKeyFrames().add(new KeyFrame(Duration.seconds(0.4), new Pulsate()));
		_pulsate.setCycleCount(Animation.INDEFINITE);
		_pulsate.play();

		_horTestLine = new Line(0,0,0,0);
		_vertTestLine = new Line(0,0,0,0);
	}
	
	public void pauseAll()	{
		_mario.pauseAll();
		for (Enemy enemy : _enemies) {
			enemy.pauseAll();
		}
		for (Item item : _items) {
			item.pauseAll();
		}
		for (Offensives attack : _offensives) {
			attack.pauseAll();
		}
		for (Character character : _uninteractive) {
			character.pauseAll();
		}
		_paused = true;
	}
	
	public void playAll()	{
		_mario.playAll();
		for (Enemy enemy : _enemies) {
			enemy.playAll();
		}
		for (Item item : _items) {
			item.playAll();
		}
		for (Offensives attack : _offensives) {
			attack.playAll();
		}
		for (Character character : _uninteractive) {
			character.playAll();
		}
		_paused = false;
	}
	
	private Square nextBlock(double newX, double newY, Character character, boolean forJump)	{
		Line test = null;
		if (forJump) {
			_horTestLine.setStartX(character.getBody().getX() + 5);
			_horTestLine.setEndX(character.getBody().getX() + character.getBody().getWidth() - 5);
			_horTestLine.setStartY(newY);
			_horTestLine.setEndY(newY);
			test = _horTestLine;
		}
		else	{
			int weight = 0;
			if (character.getDir() == Direction.RIGHT) {
				weight = 1;
			}
			_vertTestLine.setStartX(newX + character.getBody().getWidth()*weight);
			_vertTestLine.setEndX(newX + character.getBody().getWidth()*weight);
			_vertTestLine.setStartY(character.getBody().getY() + 5);
			_vertTestLine.setEndY(character.getBody().getY() + character.getBody().getHeight() - 5);
			test = _vertTestLine;
		}
		for (Square[] squares : _squaresOnScreen)	{
			for (Square square : squares)	{
				if (square.getBody().intersects(test.getBoundsInLocal())
						&& !square.isFree()) {
					return square;
				}
			}
		}
		return null;
	}

	private class PressHandler implements EventHandler<KeyEvent>	{
		
		public PressHandler()	{}
		
		@Override
		public void handle(KeyEvent event)	{
			if (!_paused && !_mario.isDead())	{
				KeyCode keyPressed = event.getCode();
				switch (keyPressed)	{
				case LEFT:
					_mario.setDir(Direction.LEFT);
					_mario.getBody().setRotate(180);
					if (_mario.getMoveTL().getStatus() != Status.RUNNING)	{
						_mario.getMoveTL().play();
						if (_mario.getAnimate().getStatus() != Status.RUNNING)	{
							_mario.switchCostume();
							_mario.getAnimate().play();
						}
					}
					break;
				case RIGHT:
					_mario.setDir(Direction.RIGHT);
					_mario.getBody().setRotate(0);
					if (_mario.getMoveTL().getStatus() != Status.RUNNING)	{
						_mario.getMoveTL().play();
						if (_mario.getAnimate().getStatus() != Status.RUNNING)	{
							_mario.switchCostume();
							_mario.getAnimate().play();
						}
					}
					break;
				case SPACE:
					if (_mario.getJumpTL().getStatus() == Status.STOPPED/*RUNNING*/) {
						_mario.getBody().setFill(_mario.getDeadJump()[1]);
						_mario.getAnimate().pause();
						_mario.setVelocity(Constants.INIT_V);
						_mario.getJumpTL().play();
					}
//					if (_mario.getVelocity() < 0 /*-600*/
//							&& _mario.getVelocity() > Constants.INIT_V*5/6) {
//						_mario.setVelocity(0);
//					}
					break;
				case DOWN:
					break;
				case E:
					System.out.println(_enemies.size());
					break;
				case Q:
					Platform.exit();
					break;
				case F:
					Fireball fireball = new Fireball(_gamespace,_mario.getBody().getX() + _mario.getBody().getWidth(), _mario.getBody().getY());
					_offensives.add(fireball);	//arguments are position, not coordinates
					addNPCKeyFrame(fireball);
					fireball.getMoveTL().play();
					break;
				default:
					break;
				}
			}
			
			event.consume();
		}
	}
	//make pause and stop all the same
	private class Jump implements EventHandler<ActionEvent>	{

		private ArrayList<Enemy> _removeable;
		private Character _jumping;
		private Object _LOCK = new Object();
		
		public Jump(Character jumping)	{
			_jumping = jumping;
			_jumping.setVelocity(Constants.INIT_V);
			_removeable = new ArrayList<Enemy>();
		}
		
		@SuppressWarnings("unlikely-arg-type")
		@Override
        public void handle(ActionEvent e) {
			_jumping.updateVelocity();
			Rectangle body = _jumping.getBody();
			double newY = body.getY() + _jumping.getVelocity() * Constants.DURATION;
			Square nextBlock = null;
			Line foot = new Line(body.getX(), body.getY() + body.getHeight(), 
					body.getX() + body.getHeight(), body.getY() + body.getHeight());
			
			if (_jumping.isDead())	{
				body.setY(newY);
			}
			else if (_jumping.getVelocity() > 0)	{
				nextBlock = nextBlock(body.getX(), newY + body.getHeight(), _jumping, true);//nextBlockForJump(newY + body.getHeight(), _jumping);
				if (nextBlock != null && !_jumping.isDead())	{	//when it lands
					body.setY(nextBlock.getBody().getY() - body.getHeight() - 1);
					_jumping.onHittingGround();
				}
				else	{ 
					body.setY(newY);
				}
				
				if (!_jumping.isNPC()) {
					for (Enemy enemy : _enemies)	{	//checks to see if mario is jumping on an enemy
						Rectangle enemyHead = new Rectangle(enemy.getBody().getX(), enemy.getBody().getY(), 
								enemy.getBody().getHeight(), enemy.getBody().getHeight()/3);
						if (enemyHead.intersects(foot.getBoundsInLocal())
								&& !enemy.isDead())	{
							_jumping.setVelocity(Constants.INIT_V);
							this.detEnemyAction(enemy);
						}
						break;	//patch
					}
				}
				
			}	
			else if (_jumping.getVelocity() <= 0)	{
				nextBlock = nextBlock(body.getX(), newY, _jumping, true);//nextBlockForJump(newY, _jumping);
				if (nextBlock != null)	{
					_jumping.setVelocity(_jumping.getVelocity()*-1);
					body.setY(nextBlock.getBody().getY() + nextBlock.getBody().getHeight() + 1);
					this.detBlockAction(nextBlock);
				}
				body.setY(newY);
			}
			
			if (body.getY() > Constants.MAX_Y)	{
				_enemies.remove(_jumping);
				_items.remove(_jumping);
				_offensives.remove(_jumping);
				_uninteractive.remove(_jumping);
				_gamespace.getChildren().remove(body);
				_jumping.pauseAll();
				if (!_jumping.isNPC())	{
					Platform.exit();
				}
			}
			
			_enemies.removeAll(_removeable);
			_removeable.clear();
			
			e.consume();
        }
		
		@SuppressWarnings("unlikely-arg-type")
		private void detBlockAction(Square block)	{
			if (!block.isImpacted() && !_jumping.isNPC())	{
				switch (block.getType())	{
				case BRICK:
					if (_mario.isBig())	{
						block.delete();
					}
					else	{
						block.getBop().play();
					}
					break;
				case COIN:
				case MUSHROOM:
				case FLOWER:
				case STAR:
					this.newItem(block);
					block.delete();
					_pulsating.remove(block);
					break;
				default:
					break;
				}
				for (Enemy enemy : _enemies)	{ //kills enemies if block under them is hit
					Line enemyFoot = new Line(block.getBody().getX(), block.getBody().getY() - 1, 
							block.getBody().getX() + enemy.getBody().getHeight(), block.getBody().getY() - 1);
					if (enemy.getBody().intersects(enemyFoot.getBoundsInLocal())) {
						if (enemy.getType() == Type.KOOPA) {
							enemy.getBody().setRotationAxis(Rotate.X_AXIS);
							enemy.getBody().setRotate(180);
//							enemy.getBody().setRotationAxis(Rotate.Y_AXIS);
							enemy.setVelocity(-200);
							enemy.getJumpTL().play();
							enemy.rogueAction(Direction.NONE);
						}
						else	{
							enemy.deathAnimation();
						}
					}
				}
			}
		}
		
		private void newItem(Square block)	{
			//puts an item on the screen depending on what block was hit
			Item item = null;
			switch (block.getType())	{
			case COIN:
				/*item = */_uninteractive.add(new Coin(_gamespace, block.getBody().getX() + 3*Constants.BLOCK_LENGTH/8,
						block.getBody().getY() - Constants.BLOCK_LENGTH/2, Type.COIN));
//				addNPCKeyFrame(item);
				break;
			case MUSHROOM:
				item = new Mushroom(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.MUSHROOM);
				addNPCKeyFrame(item);
				break;
			case FLOWER:
				item = new Flower(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.FLOWER);
				addNPCKeyFrame(item);
				break;
			case STAR:
				item = new Star(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.STAR);
				addNPCKeyFrame(item);
				break;
			default:
				break;
			}
			_sky.toBack();
			if (item!=null)	{
				_items.add(item);
			}
		}
		
		private void detEnemyAction(Enemy enemy)	{
			//initiates an enemy's reponse to being jumped on
			switch (enemy.getType())	{
			case GOOMBA:
				enemy.delete();
//				Thread.sleep(300);
//				synchronized (_LOCK) {
//				        _LOCK.wait();
//				    }
				_gamespace.getChildren().remove(enemy.getBody());
				_enemies.remove(enemy);
				break;
			case KOOPA:
				Direction dir = Direction.NONE;
				if (_mario.getBody().getX() < enemy.getBody().getX() + 11*_mario.getBody().getWidth()/24)	{
					dir = Direction.RIGHT;
				}
				else if (_mario.getBody().getX() + _mario.getBody().getWidth() > enemy.getBody().getX() + 13*_mario.getBody().getWidth()/24)	{
					dir = Direction.LEFT;
				}
				enemy.rogueAction(dir);
				//if mario touches the bottom half he dies
				break;
			default:
				break;
			}
		}
		
	}
	
	private class Move implements EventHandler<ActionEvent>	{

		private Character _moving;
		private Object _LOCK = new Object();
		
		public Move(Character npc)	{
			_moving = npc;
		}
	
		@Override
        public void handle(ActionEvent e) {
			double displacement = _moving.getDir().direction()*Constants.DISPLACEMENT*_moving.getFasterWeight();
			Rectangle body = _moving.getBody();
			double newX = body.getX() + displacement;
			if (_moving.isDead()) {
				body.setX(newX);
			}
			else if (nextBlock(body.getX(), body.getY() + 1 + body.getHeight(), _moving, true)/*nextBlockForJump(body.getY() + 1 + body.getHeight(), _moving)*/ == null
					&& _moving.getJumpTL().getStatus() == Status.STOPPED)	{
				_moving.fall();
			}
			else if (/*nextBlockForMove(newX, _moving)*/nextBlock(newX, body.getY(), _moving, false) == null
					&& (!nextToNPC() || _moving.isRogue()))	{ //if mario is moving to a free block
				if (!_moving.isNPC())	{
					if (newX >= Constants.MAX_X
							&& _colsDeleted < Constants.TOT_BLOCKS_WIDE - Constants.BLOCKS_WIDE) {	//if mario is at scrolling distance and the end of the level is not reached
						this.adjustSquares();
						this.checkScroll();
					}
				}
				_moving.move(displacement);
			}
			else if (_moving.isNPC() && !_moving.isDead())	{
				_moving.flip();
			}

			Rectangle deathZone = new Rectangle(body.getX(), body.getY() + body.getHeight()/2, 
					body.getHeight(), body.getHeight()/2);
			if (_mario.getBody().intersects(deathZone.getBoundsInLocal()) && !_mario.isDead() && !_mario.getBlinking()
					& !_moving.isDead() && _moving.isEnemy())	{
				_mario.die();
			}
			else if (_moving.getBody().intersects(_mario.getBody().getBoundsInLocal())
					&& _moving.isNPC() && !_moving.isEnemy())	{
				this.initEffect();
			}
			else if (_moving.getBody().intersects(_mario.getBody().getBoundsInLocal())
//					&& !_moving.isNPC() 
					&& _moving.isRogue()
					&& _moving.getMoveTL().getStatus() == Status.PAUSED
//					&& _mario.getJumpTL().getStatus() != Status.RUNNING
					)	{
				_moving.getBody().setX(_moving.getBody().getX() + 10*Constants.DISPLACEMENT*_mario.getFasterWeight()*_mario.getDir().direction());
				_moving.rogueAction(_mario.getDir());
			}
//			if (_mario.getBody().intersects(body.getBoundsInLocal()) && !_mario.isDead()
//					&& !_moving.isDead() && !_moving.isEnemy() && _moving.isNPC())	{
//				this.initEffect();
//			}
//			for (Item item : _items)	{
//				if (_moving.getBody().intersects(item.getBody().getBoundsInLocal())
//						&& !_moving.isNPC() )	{
//					this.initEffect();
//				}
//			}
//			for (Enemy enemy : _enemies)	{
//				if (_moving.getBody().intersects(enemy.getBody().getBoundsInLocal())
//						&& !_moving.isNPC() 
//						&& enemy.isRogue()
//						&& enemy.getMoveTL().getStatus() == Status.PAUSED
//						&& _mario.getJumpTL().getStatus() != Status.RUNNING)	{
//					enemy.getBody().setX(enemy.getBody().getX() + 10*Constants.DISPLACEMENT*_mario.getFasterWeight()*_mario.getDir().direction());
//					enemy.rogueAction(_mario.getDir());
//				}
//			}
			
			e.consume();
        }
		
		private void checkScroll()	{
			if (_squaresOnScreen[0][0].getBody().getX() <= -1 * Constants.BLOCK_LENGTH) {
				this.shiftArrays();
				_mario.getBody().toFront();
				if (_colsDeleted != Constants.TOT_BLOCKS_WIDE + Constants.BLOCKS_WIDE)	{
					_colsDeleted++;
				}
			}
		}
		
		private void shiftArrays()	{
//			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
//				_gamespace.getChildren().remove(_squaresOnScreen[i][0].getBody());
//			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++)	{	//moves columns of array one space to the left
				for (int j = 1 ; j < Constants.OFFSET; j++)	{
					_squaresOffScreen[i][j-1] = _squaresOffScreen[i][j];
				}
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++)	{	//moves the leftmost column of onscreen to rightmost of offscreen
				_squaresOffScreen[i][Constants.OFFSET-1] = _squaresOnScreen[i][0];
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH; i++)	{	//moves columns of array one space to the left
				for (int j = 1 ; j < Constants.BLOCKS_WIDE; j++)	{
					_squaresOnScreen[i][j-1] = _squaresOnScreen[i][j];
				}
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {	//generate new squares, going down the column
				_squaresOnScreen[i][Constants.BLOCKS_WIDE-1] = 
						detNewPiece(i, Constants.BLOCKS_WIDE-1);
			}
//			for (Enemy enemy : _enemies) {
//				enemy.getBody().toFront();
//			}
//			for (Item item : _items) {
//				if (item.getRiseTL().getStatus() == Status.STOPPED)	{
//					item.getBody().toFront();
//				}
//			}
//			for (Offensives attack : _offensives) {
//				attack.getBody().toFront();
//			}
		}
		
		private void adjustSquares()	{
			for (Square[] pieces : _squaresOffScreen)	{
				for (Square piece : pieces)	{
					piece.getBody().setX(piece.getBody().getX() - Constants.DISPLACEMENT*_mario.getFasterWeight());
					if (piece.getBody().getX() < -1 * piece.getBody().getWidth() - Constants.OFFSET*Constants.BLOCK_LENGTH)	{
						piece.delete();
					}
				}
			}
			for (Square[] squares : _squaresOnScreen)	{
				for (Square square : squares)	{
					square.getBody().setX(square.getBody().getX() - Constants.DISPLACEMENT*_mario.getFasterWeight());
				}
			}
			Enemy removeable = null;
			for (Enemy enemy : _enemies) {
				enemy.getBody().setX(enemy.getBody().getX() - Constants.DISPLACEMENT*_mario.getFasterWeight());
				if (enemy.getBody().getX() < -1 * Constants.OFFSET*Constants.BLOCK_LENGTH)	{
					removeable = enemy;
					break;
				}
			}
			_enemies.remove(removeable);
			for (Item item : _items) {//same
				item.getBody().setX(item.getBody().getX() - Constants.DISPLACEMENT*_mario.getFasterWeight());
				if (item.getBody().getX() < -Constants.OFFSET*Constants.BLOCK_LENGTH)	{
					_items.remove(item);
					item = null;
					break;
				}
			}
			for (Offensives attack : _offensives) {//same
				attack.getBody().setX(attack.getBody().getX() - Constants.DISPLACEMENT*_mario.getFasterWeight());
				if (attack.getBody().getX() < -Constants.OFFSET*Constants.BLOCK_LENGTH)	{
					_offensives.remove(attack);
					attack = null;
					break;
				}
			}
			for (Character character : _uninteractive) {//same
				character.getBody().setX(character.getBody().getX() - Constants.DISPLACEMENT*_mario.getFasterWeight());
				if (character.getBody().getX() < -Constants.OFFSET*Constants.BLOCK_LENGTH)	{
					_uninteractive.remove(character);
					break;
				}
			}
		}
		
		private void initEffect()	{
			switch (_moving.getType())	{
			case MUSHROOM:
				pauseAll();
				_mario.grow();
				break;
			case FLOWER:
				_mario.transform();
				break;
			case STAR:
				_mario.invincible();
				break;
			default:
				break;
			}
			_gamespace.getChildren().remove(_moving.getBody());
			_moving.pauseAll();
			_items.remove(_moving);
//			Thread.sleep(1400);
//			synchronized (_LOCK) {
//			        _LOCK.wait(1400);
//			    }
			playAll();
		}
		
		private boolean nextToNPC()	{
			Rectangle body = _moving.getBody();
			double weight = 0;
			if (_moving.getDir() == Direction.RIGHT) {
				weight = body.getWidth();
			}
			_vertTestLine.setStartX(body.getX() + weight);
			_vertTestLine.setEndX(body.getX() + weight);
			_vertTestLine.setStartY(body.getY());
			_vertTestLine.setEndY(body.getY() + body.getHeight());
			for (Enemy npc : _enemies)	{
				if (npc.getBody().intersects(_vertTestLine.getBoundsInLocal())
						&& !npc.getBody().equals(body))	{
					if (_moving.isRogue() && !npc.isDead())	{
						npc.deathAnimation(); 
					}
					return true;
				}
			}
			for (Item item : _items)	{
				if (item.getBody().intersects(_vertTestLine.getBoundsInLocal())
						&& !item.getBody().equals(body))	{
					return true;
				}
			}
			for (Offensives attack : _offensives)	{
				if (attack.getBody().intersects(_vertTestLine.getBoundsInLocal())
						&& !attack.getBody().equals(body))	{
					return true;
				}
			}
			return false;
		}
	}
	
	private class Pulsate implements EventHandler<ActionEvent>	{

		@Override
		public void handle(ActionEvent event) {
			if (!_pulsating.isEmpty())	{
				for (Pulsating pulsable : _pulsating)	{
					pulsable.pulsate(_count);
				}
				if (_count == Constants.MYSTERY_SET.length-1)	{
					_count = 0;
				}
				else	{
					_count++;
				}
			}
		}
		
	}
	
}







if (_mario.getVelocity() < 0 /*-600*/
								&& _mario.getVelocity() > Constants.INIT_V/2) {
							_mario.setVelocity(0);
						}
						else	{
							
						}
							
//	private Square nextBlockForJump(double newY, Character character)	{ //why dont i just have one of these
//		_horTestLine.setStartX(character.getBody().getX() + 5);
//		_horTestLine.setEndX(character.getBody().getX() + character.getBody().getWidth() - 5);
//		_horTestLine.setStartY(newY);
//		_horTestLine.setEndY(newY);
//		for (Square[] squares : _squaresOnScreen)	{
//			for (Square square : squares)	{
//				if (square.getBody().intersects(_horTestLine.getBoundsInLocal())
//						&& !square.isFree()) {
//					return square;
//				}
//			}
//		}
//		return null;
//	}
//	
//	private Square nextBlockForMove(double newX, Character character)	{
//		int weight = 0;
//		if (character.getDir() == Direction.RIGHT) {
//			weight = 1;
//		}
//		_vertTestLine.setStartX(newX + character.getBody().getWidth()*weight);
//		_vertTestLine.setEndX(newX + character.getBody().getWidth()*weight);
//		_vertTestLine.setStartY(character.getBody().getY() + 5);
//		_vertTestLine.setEndY(character.getBody().getY() + character.getBody().getHeight() - 5);
//		for (Square[] squares : _squaresOnScreen)	{
//			for (Square square : squares)	{
//				if (square.getBody().intersects(_vertTestLine.getBoundsInLocal())
//						&& !square.isFree()) {
//					return square;
//				}
//			}
//		}
//		return null;
//	}




private Square nextBlockForJump(double newY, Character character)	{ //why dont i just have one of these
//		_horTest.setStartX(character.getBody().getX() + 5);
//		_horTest.setEndX(character.getBody().getX() + character.getBody().getWidth() - 5);
//		_horTest.setStartY(newY);
//		_horTest.setEndY(newY);
//		for (Square[] squares : _squaresOnScreen)	{
//			for (Square square : squares)	{
//				if (square.getBody().intersects(_horTest.getBoundsInLocal())
//						&& !square.isFree()) {
//					return square;
//				}
//			}
//		}
//		return null;
//	}
//	
//	private Square nextBlockForMove(double newX, Character character)	{
//		int weight = 0;
//		if (character.getDir() == Direction.RIGHT) {
//			weight = 1;
//		}
//		_vertTest.setStartX(newX + character.getBody().getWidth()*weight);
//		_vertTest.setEndX(newX + character.getBody().getWidth()*weight);
//		_vertTest.setStartY(character.getBody().getY() + 5);
//		_vertTest.setEndY(character.getBody().getY() + character.getBody().getHeight() - 5);
//		for (Square[] squares : _squaresOnScreen)	{
//			for (Square square : squares)	{
//				if (square.getBody().intersects(_vertTest.getBoundsInLocal())
//						&& !square.isFree()) {
//					return square;
//				}
//			}
//		}
//		return null;
//	}





package Mario;

import java.util.ArrayList;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.animation.Animation.Status;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Label;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

public class Game	{
	
	private Pane _gamespace;
	private Timeline _timeline;
	private KeyHandler _keyEvent;
	private boolean _paused;
	private Rectangle _background;
	private Mario _mario;
	private Square[][] _squaresOnScreen;
	private Square[][] _bgPiecesOnScreen;
	private Square[][] _piecesOffScreen;
	private Line _horTest;
	private Line _vertTest;
	private Type[][] _map;
	private int _colsDeleted;
	private ArrayList<Enemy> _enemies;
	private ArrayList<Item> _items;
	private Type[][] _backgroundMap;
	private Type[][] _offScreenMap;
	
	public Game(Pane gamespace, Rectangle bg, Pane visualize)	{
		_gamespace = gamespace;
		_background = bg;
		_keyEvent = new KeyHandler();
		_gamespace.addEventHandler(KeyEvent.KEY_PRESSED, _keyEvent);
		_gamespace.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>()	{
			@Override
			public void handle(KeyEvent event) {
				KeyCode keyPressed = event.getCode();
				switch (keyPressed)	{
				case LEFT:
					_mario.getMoveTL().stop();
					if (_mario.getJumpTL().getStatus() == Status.STOPPED &&
							_mario.getFallTL().getStatus() == Status.STOPPED)	{
						_mario.getBody().setFill(Constants.MARIO1);
					}
					break;
				case RIGHT:
					_mario.getMoveTL().stop();
					if (_mario.getJumpTL().getStatus() == Status.STOPPED &&
							_mario.getFallTL().getStatus() == Status.STOPPED)	{
						_mario.getBody().setFill(Constants.MARIO1);
					}
					break;
				default:
					break;
				}
			}
		});
		this.setupGame();
		this.setupTLs();
	}
	
	private void setupGame()	{
		this.setupMap();
//		this.printSquares();
		_mario = new Mario(_gamespace, Constants.BLOCKS_HIGH-3, 0);
	}
	
	private void printSquares()	{
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++)	{
			for (int j = 0 ; j < Constants.BLOCKS_WIDE ; j++)	{
				if (j == Constants.BLOCKS_WIDE-1)	{
					System.out.println(_squaresOnScreen[i][j].getType() + "	");
				}
				else	{
					System.out.print(_squaresOnScreen[i][j].getType() + "	");
				}
			}
		}
		System.out.println("\n");
	}
	
	private void setupMap()	{ //make a new generation system where only blocks on screen are loaded
		Map temp = new Map();
		_enemies = new ArrayList<Enemy>();
		_items = new ArrayList<Item>();
		_squaresOnScreen = new Square[Constants.BLOCKS_HIGH][Constants.BLOCKS_WIDE];
		_bgPiecesOnScreen = new Square[Constants.BLOCKS_HIGH][Constants.BLOCKS_WIDE];
		_piecesOffScreen = new Square[Constants.BLOCKS_HIGH][Constants.OFFSET];
		_map = temp.getMap();
		_backgroundMap = temp.getBackground();
		_offScreenMap = temp.getOffScreen();
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
			for (int j = 0 ; j < Constants.BLOCKS_WIDE; j++)	{ 
				_squaresOnScreen[i][j] = this.detNewPiece(i, j);
				_bgPiecesOnScreen[i][j] = this.detNewBGPiece(i, j);
			}
		}
		Square piece = null;
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
			for (int j = 0 ; j < Constants.OFFSET; j++)	{ 
				switch (_offScreenMap[i][j])	{
				case FREE:
					piece = new Free(_gamespace, i, j - Constants.OFFSET);
					break;
				case FLOOR:
					piece = new Floor(_gamespace, i, j - Constants.OFFSET);
					break;
				default:
					break;
				}
				_piecesOffScreen[i][j] = piece;
			}
		}
	}
	
	private Square detNewBGPiece(int i, int j)	{
		Square bgPiece = null;
		switch (_backgroundMap[i][j + _colsDeleted])	{
		case FREE:
			bgPiece = new Free(_gamespace, i, j);
			break;
		case BIGHILL:
			bgPiece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*5, Constants.BLOCK_LENGTH*2,
					Constants.BIG_HILL, Type.BIGHILL);
			break;
		case SMALLHILL:
			bgPiece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*3, Constants.BLOCK_LENGTH,
					Constants.SMALL_HILL, Type.SMALLHILL);
			break;
		case BIGBUSH:
			bgPiece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*5, Constants.BLOCK_LENGTH,
					Constants.BIG_BUSH, Type.BIGBUSH);
			break;
		case MEDBUSH:
			bgPiece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*4, Constants.BLOCK_LENGTH,
					Constants.MED_BUSH, Type.MEDBUSH);
			break;
		case SMALLBUSH:
			bgPiece = new BackgroundNugget(_gamespace, i, j, Constants.BLOCK_LENGTH*3, Constants.BLOCK_LENGTH,
					Constants.SMALL_BUSH, Type.SMALLBUSH);
			break;
		default:
			break;
		}
		return bgPiece;
	}
	
	private Square detNewPiece(int i, int j)	{
		//System.out.println(_map[i][j + 1 + _colsDeleted]);
		Square piece = null;
		//ArrayList<Enemy> temp = null;
		//System.out.println(_colsDeleted);
		switch (_map[i][j + _colsDeleted])	{
		case PIT:
		case BIGHILL:
		case SMALLHILL:
		case BIGBUSH:
		case MEDBUSH:
		case SMALLBUSH:
		case FREE:
			piece = new Free(_gamespace, i, j);
			break;
		case GOOMBA_START:
			piece = new Free(_gamespace, i, j);
			Goomba goomba = new Goomba(_gamespace, i, j);
			this.addNPCKeyFrame(goomba);
			goomba.getMoveTL().play();
			_enemies.add(goomba);
			break;
		case KOOPA_START:
			piece = new Free(_gamespace, i, j);
			Koopa koopa = new Koopa(_gamespace, i, j);
			this.addNPCKeyFrame(koopa);
			koopa.getMoveTL().play();
			_enemies.add(koopa);
			break;
		case FLOOR:
			piece = new Floor(_gamespace, i, j);
			break;
		case BRICK:
			piece = new Brick(_gamespace, i, j);
			break;
		case PIPE_TL:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_TL);
			break;
		case PIPE_TR:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_TR);
			break;
		case PIPE_L:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_L);
			break;
		case PIPE_R:
			piece = new Pipe(_gamespace, i, j, Type.PIPE_R);
			break;
		case STAIR:
			piece = new Stair(_gamespace, i, j);
			break;
		case COIN_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.COIN);
			break;
		case MUSHROOM_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.MUSHROOM);
			break;
		case FLOWER_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.FLOWER);
			break;
		case STAR_MYSTERY:
			piece = new Mystery(_gamespace, i, j, Type.STAR);
			break;
		default:
			break;
		}
		return piece;
	}
	
	private void addNPCKeyFrame(Character npc)	{
		KeyFrame jump = new KeyFrame(Duration.seconds(Constants.DURATION), new NPCJump(npc));
		npc.getJumpTL().getKeyFrames().add(jump);
		
		KeyFrame move = new KeyFrame(Duration.seconds(Constants.DURATION), new NPCMove(npc));
		npc.getMoveTL().getKeyFrames().add(move);
		
		KeyFrame fall = new KeyFrame(Duration.seconds(Constants.DURATION), new Fall(npc));
		npc.getFallTL().getKeyFrames().add(fall);
	}
	
	private void setupTLs()	{
		KeyFrame jump = new KeyFrame(Duration.seconds(Constants.DURATION), new MarioJump());
		_mario.getJumpTL().getKeyFrames().add(jump);
		
		KeyFrame move = new KeyFrame(Duration.seconds(Constants.DURATION/4/*5*/), new MarioMove());
		_mario.getMoveTL().getKeyFrames().add(move);

		KeyFrame fall = new KeyFrame(Duration.seconds(Constants.DURATION), new Fall(_mario));
		_mario.getFallTL().getKeyFrames().add(fall);
		
		_horTest = new Line(0,0,0,0);
		_vertTest = new Line(0,0,0,0);
	}
	
	private Square nextBlockForJump(double newY, Character character)	{ //why dont i just have one of these
		_horTest.setStartX(character.getBody().getX() + 5);
		_horTest.setEndX(character.getBody().getX() + character.getBody().getWidth() - 5);
		_horTest.setStartY(newY);
		_horTest.setEndY(newY);
		for (Square[] squares : _squaresOnScreen)	{
			for (Square square : squares)	{
//				if (square.getSolid() && square.getType() != Type.FLOOR)	{
//					System.out.println(square.getType() + ":	" + square.getBody().getX());
//				}
				if (square.getBody().intersects(_horTest.getBoundsInLocal())
						&& square.getSolid()) {
					return square;
				}
			}
		}
		return null;
	}
	
	private Square nextBlockForMove(double newX, Character character)	{
		int weight = 0;
		if (_mario.getDir() == Direction.RIGHT) {
			weight = 1;
		}
		_vertTest.setStartX(newX + Constants.BLOCK_LENGTH*weight);
		_vertTest.setEndX(newX + Constants.BLOCK_LENGTH*weight);
		_vertTest.setStartY(character.getBody().getY() + 5);
		_vertTest.setEndY(character.getBody().getY() + character.getBody().getHeight() - 5);
		for (Square[] squares : _squaresOnScreen)	{
			for (Square square : squares)	{
				if (square.getBody().intersects(_vertTest.getBoundsInLocal())
						&& square.getSolid()) {
					return square;
				}
			}
		}
		return null;
	}

	private class KeyHandler implements EventHandler<KeyEvent>	{
		
		public KeyHandler()	{}
		
		@Override
		public void handle(KeyEvent event)	{
			KeyCode keyPressed = event.getCode();
			switch (keyPressed)	{
			case LEFT:
				_mario.setDir(Direction.LEFT);
				_mario.getBody().setRotate(180);
				_mario.getMoveTL().play();
				break;
			case RIGHT:
				_mario.setDir(Direction.RIGHT);
				_mario.getBody().setRotate(0);
				_mario.getMoveTL().play();
				break;
			case SPACE:
				if (_mario.getJumpTL().getStatus() == Status.STOPPED &&
				_mario.getFallTL().getStatus() == Status.STOPPED) {
//					_jumpTL.stop();
					_mario.getBody().setFill(Constants.JUMP);
					_mario.getJumpTL().play();
				}
				break;
			case DOWN:
				break;
			case P:
				if (_paused)	{
					_timeline.play();
					_paused = false;
				}
				else	{
					_timeline.pause();
					_paused = true;
				}
				break;
			case Q:
				Platform.exit();
				break;
			default:
				break;
			}
			
			event.consume();
		}
	}
	
	
	private class MarioJump implements EventHandler<ActionEvent>	{

		private ArrayList<Enemy> _removeable;
		
		public MarioJump()	{
			_mario.setVelocity(Constants.INIT_V);
			_removeable = new ArrayList<Enemy>();
		}
		
		@Override
        public void handle(ActionEvent e) {
			_mario.updateVelocity();
			double newY = _mario.getBody().getY() + _mario.getVelocity() * Constants.DURATION;
			Line marioFoot = new Line(_mario.getBody().getX(), _mario.getBody().getY() + _mario.getBody().getHeight(), 
					_mario.getBody().getX() + _mario.getBody().getHeight(), _mario.getBody().getY() + _mario.getBody().getHeight());
			Line marioHead = new Line(_mario.getBody().getX(), _mario.getBody().getY(), 
					_mario.getBody().getX() + _mario.getBody().getHeight(), _mario.getBody().getY());
			Square nextBlock = null;
			if (_mario.getDead()) {
				_mario.getBody().setY(newY);
			}
			else if (_mario.getVelocity() > 0)	{
				nextBlock = nextBlockForJump(newY + _mario.getBody().getHeight(), _mario);
				for (Enemy enemy : _enemies)	{
					Rectangle npcHead = new Rectangle(enemy.getBody().getX(), enemy.getBody().getY(), 
							enemy.getBody().getHeight(), enemy.getBody().getHeight()/3);
					if (npcHead.intersects(marioFoot.getBoundsInLocal())
							&& !enemy.getDead())	{
						this.detEnemyAction(enemy);
						_mario.setVelocity(Constants.INIT_V);
					}
				}
//				for (CollidableBlock block : _blocks)	{
////					if (nextBlock != null)	{
//					Line blockBottom = new Line(block.getBody().getX(), block.getBody().getY() + Constants.MARIO_LENGTH,
//							block.getBody().getX() + Constants.MARIO_LENGTH, block.getBody().getY() + Constants.MARIO_LENGTH);
////						_mario.getBody().setY(nextBlock.getBody().getY() - Constants.MARIO_LENGTH - 1);
////						_mario.getBody().setFill(Constants.MARIO1);
////						_mario.getJumpTL().stop();
//					if (blockBottom.intersects(marioFoot.getBoundsInLocal())
//							&& !block.getImpacted())	{
//						newY = _mario.getBody().getY() + _mario.getVelocity() * Constants.DURATION;
//						_mario.setVelocity(Constants.INIT_V);
//					}
////					}
//				}
				if (nextBlock != null)	{
					_mario.setVelocity(Constants.INIT_V);
					_mario.getBody().setY(nextBlock.getBody().getY() - _mario.getBody().getHeight() - 1);
					_mario.getBody().setFill(Constants.MARIO1);
					_mario.getJumpTL().stop();
				}
				else	{ 
					_mario.getBody().setY(newY);
				}
			}
			else if (_mario.getVelocity() <= 0)	{
				nextBlock = nextBlockForJump(newY, _mario);
//				System.out.println(nextBlock);
//				for (CollidableBlock block : _blocks)	{
//					System.out.println(block.getType());
//					Rectangle blockBottom = new Rectangle(block.getBody().getX(), block.getBody().getY() + 5,
//							Constants.MARIO_LENGTH, Constants.MARIO_LENGTH - 5);
//					if (blockBottom.intersects(marioHead.getBoundsInLocal())
//							&& !block.getImpacted())	{
//						_mario.setVelocity(_mario.getVelocity()*-1);
//						System.out.println("hit");
//						newY = _mario.getBody().getY() + _mario.getVelocity() * Constants.DURATION;
//					}
//				}
				if (nextBlock != null)	{
					_mario.setVelocity(_mario.getVelocity()*-1);
					_mario.getBody().setY(nextBlock.getBody().getY() + _mario.getBody().getHeight() + 1);
					this.detBlockAction(nextBlock);
				}
				_mario.getBody().setY(newY);
			}
			if (_mario.getBody().getY() > Constants.GAME_HEIGHT)	{
				Platform.exit();
			}
			
			e.consume();
        }
		
		private void detBlockAction(Square block)	{
			if (!block.getImpacted())	{
				switch (block.getType())	{
				case BRICK:
					block.delete();
					System.out.println("brick");
					break;
				case COIN:
				case MUSHROOM:
				case FLOWER:
				case STAR:
					_items.add(this.chooseItem(block));
					block.getBody().toFront();
					block.delete();
					break;
				default:
					break;
				}
				ArrayList<Enemy> removeable = new ArrayList<Enemy>();
				for (Enemy enemy : _enemies)	{ //kills enemies if block under them is hit
					Line enemyFoot = new Line(block.getBody().getX(), block.getBody().getY() - 1, 
							block.getBody().getX() + enemy.getBody().getHeight(), block.getBody().getY() - 1);
					if (enemy.getBody().intersects(enemyFoot.getBoundsInLocal())) {
						enemy.getBody().setY(enemy.getBody().getY() - 2);
						enemy.deathAnimation();
						_removeable.add(enemy);
	//					if (content.getType() == Type.KOOPA)	{
	//						detShellProcedure(content);
	//					}
					}
				}
			}
		}
		
		private Item chooseItem(Square block)	{
			Item item = null;
			switch (block.getType())	{
			case COIN:
				item = new Coin(_gamespace, block.getBody().getX() + 3*Constants.BLOCK_LENGTH/8,
						block.getBody().getY() - Constants.BLOCK_LENGTH/2, Type.COIN);
				addNPCKeyFrame(item);
				break;
			case MUSHROOM:
				item = new Mushroom(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.MUSHROOM);
				addNPCKeyFrame(item);
				break;
			case FLOWER:
				item = new Flower(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.FLOWER);
				addNPCKeyFrame(item);
				break;
			case STAR:
				item = new Star(_gamespace, block.getBody().getX(), block.getBody().getY(), Type.STAR);
				addNPCKeyFrame(item);
				break;
			default:
				break;
			}
			return item;
		}
		
		private void detEnemyAction(Enemy enemy)	{
			switch (enemy.getType())	{
			case GOOMBA:
				enemy.delete();
				_removeable.add(enemy);
				break;
			case KOOPA:
//				detShellProcedure(content);
				//if mario touches the bottom half he dies
				break;
			default:
				break;
			}
		}
		
	}
	
	private class MarioMove implements EventHandler<ActionEvent>	{
		
		public MarioMove()	{}
	
		@Override
        public void handle(ActionEvent e) {
			if (nextBlockForJump(_mario.getBody().getY() + 1 + _mario.getBody().getHeight(), _mario) == null
					&& _mario.getJumpTL().getStatus() == Status.STOPPED
					&& _mario.getFallTL().getStatus() == Status.STOPPED)	{
				_mario.resetVelocity();
				_mario.getBody().setFill(Constants.JUMP);
				_mario.getFallTL().play();
			}
			if (nextBlockForMove(_mario.getBody().getX() + _mario.getDir().distance()*Constants.DISPLACEMENT, _mario) == null
					&& !_mario.getDead())	{ //if mario is moving to a free block
				if (_mario.getBody().getX() + Constants.DISPLACEMENT >= Constants.MAX_X
						&& _colsDeleted < Constants.TOT_BLOCKS_WIDE - Constants.BLOCKS_WIDE) {//if mario is at scrolling distance and the end of the level is not reached
					this.adjustSquares();
					if (_squaresOnScreen[0][0].getBody().getX() < -1 * Constants.BLOCK_LENGTH) {
						this.shiftArrays();
						_mario.getBody().toFront();
						if (_colsDeleted != Constants.TOT_BLOCKS_WIDE + Constants.BLOCKS_WIDE)	{
							_colsDeleted++;
						}
					}
				}
				_mario.move();
				if (_mario.getJumpTL().getStatus() == Status.STOPPED
						&& _mario.getFallTL().getStatus() == Status.STOPPED) {
					_mario.switchCostume();
				}
			}
			
			for (Enemy enemy : _enemies)	{
				Rectangle deathZone = new Rectangle(enemy.getBody().getX(), enemy.getBody().getY() + _mario.getBody().getHeight()/3, 
						_mario.getBody().getHeight(), 2*_mario.getBody().getHeight()/3);
				if (_mario.getBody().intersects(deathZone.getBoundsInLocal()))	{
					_mario.die();
				}
			}
			
			e.consume();
        }
		
		
		private void shiftArrays()	{
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
				_gamespace.getChildren().remove(_squaresOnScreen[i][0].getBody());
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++)	{
				for (int j = 1 ; j < Constants.OFFSET + 1 ; j++)	{
					if (j == Constants.OFFSET) {
						_piecesOffScreen[i][j-1] = _bgPiecesOnScreen[i][0];
					}
					else	{
						_piecesOffScreen[i][j-1] = _piecesOffScreen[i][j];
					}
				}
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH; i++)	{
				for (int j = 1 ; j < Constants.BLOCKS_WIDE; j++)	{
					_bgPiecesOnScreen[i][j-1] = _bgPiecesOnScreen[i][j];
					_squaresOnScreen[i][j-1] = _squaresOnScreen[i][j];
				}
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
				_bgPiecesOnScreen[i][Constants.BLOCKS_WIDE-1] = 
						detNewBGPiece(i, Constants.BLOCKS_WIDE-1);
				_squaresOnScreen[i][Constants.BLOCKS_WIDE-1] = 
						detNewPiece(i, Constants.BLOCKS_WIDE-1);
			}
			for (Enemy enemy : _enemies) {
				enemy.getBody().toFront();
			}
			for (Item item : _items) {
				if (item.getAnimTL().getStatus() == Status.STOPPED)	{
					item.getBody().toFront();
				}
			}
		}
		
		private void adjustSquares()	{
			for (Square[] pieces : _piecesOffScreen)	{
				for (Square piece : pieces)	{
					piece.getBody().setX(piece.getBody().getX() - Constants.DISPLACEMENT);
					if (piece.getBody().getX() < -1 * piece.getBody().getWidth())	{
						_gamespace.getChildren().remove(piece.getBody());;
					}
				}
			}
			for (Square[] bgs : _bgPiecesOnScreen)	{
				for (Square bg : bgs)	{
					bg.getBody().setX(bg.getBody().getX() - Constants.DISPLACEMENT);
				}
			}
			for (Square[] squares : _squaresOnScreen)	{
				for (Square square : squares)	{
					square.getBody().setX(square.getBody().getX() - Constants.DISPLACEMENT);
				}
			}
			Enemy removeable = null;
			for (Enemy enemy : _enemies) {
				enemy.getBody().setX(enemy.getBody().getX() - Constants.DISPLACEMENT);
				if (enemy.getBody().getX() < -Constants.OFFSET*Constants.BLOCK_LENGTH)	{
					removeable = enemy;
					break;
				}
			}
			_enemies.remove(removeable);
			for (Item item : _items) {
				item.getBody().setX(item.getBody().getX() - Constants.DISPLACEMENT);
				if (item.getBody().getX() < -Constants.OFFSET*Constants.BLOCK_LENGTH)	{
					_items.remove(item);
					item = null;
					break;
				}
			}
//			printSquares();
		}
	}
	
	private class Fall implements EventHandler<ActionEvent>	{
		
		private Character _npc;
		
		public Fall(Character npc)	{
			_npc = npc;
		}
		
		@Override
        public void handle(ActionEvent e) {
			_npc.updateVelocity();
			double newY = _npc.getBody().getY() + _npc.getVelocity() * Constants.DURATION;
			Square nextBlock = nextBlockForJump(newY + _mario.getBody().getHeight(), _npc);
			if (nextBlock != null && !_npc.getDead())	{
				_npc.setVelocity(Constants.INIT_V);
				_npc.getBody().setY(nextBlock.getBody().getY() - _mario.getBody().getHeight() - 1);
				_npc.getFallTL().stop();
			}
			else	{ 
				_npc.getBody().setY(newY);
			}
			if (_mario.getBody().getY() > Constants.GAME_HEIGHT)	{
				Platform.exit();
			}
			if (_npc.getBody().getY() > Constants.MAX_Y)	{
//				_npc = null
			}
			
			e.consume();
        }
	}
	
	private class NPCMove implements EventHandler<ActionEvent>	{
		
		private Character _npc;
		
		public NPCMove(Character npc)	{
			_npc = npc;
		}
	
		@Override
        public void handle(ActionEvent e) {
			if (nextBlockForJump(_npc.getBody().getY() + 1 + _npc.getBody().getHeight(), _npc) == null
					&& _npc.getJumpTL().getStatus() == Status.STOPPED
					&& _npc.getFallTL().getStatus() == Status.STOPPED)	{ //for falling
				_npc.resetVelocity();
				_npc.getFallTL().play();
			}
			if (_npc.getDead()) {
				_npc.getBody().setX(_npc.getBody().getX() + _npc.getDir().distance()*Constants.DISPLACEMENT);
			}
			else if (nextBlockForMove(_npc.getBody().getX() + _npc.getDir().distance()*Constants.DISPLACEMENT, _npc) == null
					&& _npc.getBody().getX() + _npc.getDir().distance()*Constants.DISPLACEMENT < Constants.GAME_WIDTH
					&& !nextToNPC()) {
				_npc.getBody().setX(_npc.getBody().getX() + _npc.getDir().distance()*Constants.DISPLACEMENT);
			}
			else /*if (nextToEnemy() || checkNextBlockForMove(_body.getX() + getDir().distance()*Constants.DISPLACEMENT, _body.getY()) != null)*/	{
				_npc.setDir(_npc.getDir().opposite());
				_npc.getBody().setRotate(180 + _npc.getBody().getRotate());
			}
			if (_npc.getBody().getY() > Constants.GAME_HEIGHT)	{
				_npc.stopAll();
				_gamespace.getChildren().remove(_npc.getBody());
			}
			
			Rectangle deathZone = new Rectangle(_npc.getBody().getX(), _npc.getBody().getY() + _npc.getBody().getHeight()/3, 
					_npc.getBody().getHeight(), 2*_npc.getBody().getHeight()/3);
			if (_mario.getBody().intersects(deathZone.getBoundsInLocal()))	{
				if (_npc.isEnemy())	{
					_mario.die();
				}
				else	{
					this.initEffect();
				}
			}
			
			e.consume();
        }
		
		public void initEffect()	{
			switch (_npc.getType())	{
			case MUSHROOM:
				_mario.grow();
				break;
			case FLOWER:
				_mario.transform();
				break;
			case STAR:
				_mario.invincible();
				break;
			default:
				break;
			}
			_gamespace.getChildren().remove(_npc.getBody());
			_npc.stopAll();
			_items.remove(_npc);
		}
		
		public boolean nextToNPC()	{
			int weight = 0;
			if (_npc.getDir() == Direction.RIGHT) {
				weight = 1;
			}
			_vertTest.setStartX(_npc.getBody().getX() + _npc.getBody().getHeight()*weight + _npc.getDir().distance());
			_vertTest.setEndX(_npc.getBody().getX() + _npc.getBody().getHeight()*weight + _npc.getDir().distance());
			_vertTest.setStartY(_npc.getBody().getY());
			_vertTest.setEndY(_npc.getBody().getY() + _npc.getBody().getHeight());
			for (Enemy npc : _enemies)	{
				if (npc.getBody().intersects(_vertTest.getBoundsInLocal())
						&& !npc.getBody().equals(_npc.getBody()))	{
					return true;
				}
			}
			for (Item item : _items)	{
				if (item.getBody().intersects(_vertTest.getBoundsInLocal())
						&& !item.getBody().equals(_npc.getBody()))	{
					return true;
				}
			}
			return false;
		}
		
	}
	
	private class NPCJump implements EventHandler<ActionEvent>	{
		
		private Character _npc;
		
		public NPCJump(Character npc)	{
			_npc = npc;
		}
		
		@Override
        public void handle(ActionEvent e) {
			_npc.updateVelocity();
			double newY = _npc.getBody().getY() + _npc.getVelocity() * Constants.DURATION;
			Square nextBlock = nextBlockForJump(newY + _npc.getBody().getHeight(), _npc);
			if (nextBlock != null && !_npc.getDead())	{
				_npc.setVelocity(Constants.INIT_V);
				_npc.getBody().setY(nextBlock.getBody().getY() - _npc.getBody().getHeight() - 1);
			}
			else	{ 
				_npc.getBody().setY(newY);
			}
			if (_npc.getBody().getY() > Constants.MAX_Y)	{
//				_npc = null;
			}
			
			e.consume();
        }
	}
	
}




public void idk()	{
		switch(_type)	{
	case COIN:
		_item.setX(_body.getX() + Constants.MARIO_LENGTH/2 - Constants.MARIO_LENGTH/8);
		_item.setY(_body.getY() - Constants.MARIO_LENGTH/2);
		body.setWidth(Constants.MARIO_LENGTH/4);
		body.setHeight(Constants.MARIO_LENGTH/2);
		_item.setFill(Constants.COIN1);
		break;
	case MUSHROOM:
		_item.setX(_body.getX());
		_item.setFill(Constants.MUSHROOM);
		break;
	case FLOWER:
		_item.setX(_body.getX());
		_item.setFill(Constants.FLOWER);
		break;
	case STAR:
		_item.setX(_body.getX());
		_item.setFill(Constants.STAR);
		break;
	default:
		break;
	}
	if (_itemTL.getStatus() == Status.STOPPED)	{
		_parent.getChildren().remove(_body);
		_parent.getChildren().addAll(_item, _body);
		_itemTL.play();
	}
	}




case KOOPA:
				enemy.getBody().setFill(Constants.KOOPA_SHELL);
				if (_mario.getBody().getX() < enemy.getBody().getX() + Constants.MARIO_LENGTH/2 + 1
						&& _mario.getBody().getX() > enemy.getBody().getX())	{
					if (enemy.getDir() == Direction.LEFT)	{
						enemy.getMoveTL().stop();
						System.out.println("stopping");
					}
					else	{
						enemy.setDir(Direction.LEFT);
					}
				}
				else if (_mario.getBody().getX() + Constants.MARIO_LENGTH < enemy.getBody().getX() &&
						_mario.getBody().getX() + Constants.MARIO_LENGTH >= enemy.getBody().getX() + Constants.MARIO_LENGTH/2 - 1)	{
					if (enemy.getDir() == Direction.RIGHT)	{
						enemy.getMoveTL().stop();
					}
					else	{
						enemy.setDir(Direction.RIGHT);
					}
				}
				enemy.getMoveTL().play();
				break;
				





if (_mario.getBody().getX() + Constants.MARIO_LENGTH < enemy.getBody().getX() + Constants.MARIO_LENGTH/2
						&& _mario.getBody().getX() + Constants.MARIO_LENGTH >= enemy.getBody().getX() )	{
					enemy.setDir(Direction.RIGHT);
					System.out.println("right");
				}
				else if (_mario.getBody().getX() < enemy.getBody().getX() + Constants.MARIO_LENGTH &&
						_mario.getBody().getX() >= enemy.getBody().getX() + Constants.MARIO_LENGTH/2)	{
					enemy.setDir(Direction.LEFT);
					System.out.println("left");
				}








Square bg = null;
			Square square = null;
//			for (int i = 0 ; i < Constants.BLOCKS_HIGH; i++)	{
//				for (int j = 1 ; j < Constants.BLOCKS_WIDE; j++)	{
//					bg = _bgPiecesOnScreen[i][j];
//					bg.setX(bg.getBody().getX() - Constants.DISPLACEMENT);
//					square = _squaresOnScreen[i][j];
//					square.setX(square.getBody().getX() - Constants.DISPLACEMENT);
//				}
//			}









VVVVVallows u to put objects behind the left side of the screen maybe idk

public void addBGPieces()	{
		int loc = 0;
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
			for (int j = -1 * Constants.OFFSET ; j < Constants.TOT_BLOCKS_WIDE ; j++) {
				int offsetJ = j + Constants.OFFSET;
				//if (j > 0) {
					loc = offsetJ + i*Constants.TOT_BLOCKS_WIDE;
					if (this.bgLoc(loc, i , offsetJ))	{}
					else	{
						_background[i][offsetJ] = Type.FREE;
						_map[i][offsetJ] = Type.FREE;
					}
				//}
//				else	{
//					_background[i][offsetJ] = Type.FREE;
//				}
			}
		}
	}

public void addOthers()	{
		int loc = 0;
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
			for (int j = -Constants.OFFSET ; j < Constants.TOT_BLOCKS_WIDE ; j++) {
				int offsetJ = j + Constants.OFFSET;
				loc = offsetJ + i*Constants.TOT_BLOCKS_WIDE;
				if (this.brickLoc(loc))	{
					_map[i][offsetJ] = Type.BRICK;
				}
				else if (this.pitLoc(loc))	{
					_map[i][offsetJ] = Type.PIT;
				}
				else if (this.stairLoc(loc))	{
					_map[i][offsetJ] = Type.STAIR;
				}
				else if (this.mysteryLoc(loc))	{
					_map[i][offsetJ] = Type.MYSTERY;
				}
				else if (this.enemyLoc(loc, i, offsetJ))	{}
				else if (this.pipeLoc(loc, i, offsetJ))	{}
				else	{
					_map[i][offsetJ] = Type.FREE;
					//System.out.println("free");
				}
			}
		}
	}
	
	public void addFloor()	{
		for (int i = Constants.BLOCKS_HIGH-2 ; i < Constants.BLOCKS_HIGH ; i++) {
			for (int j = -Constants.OFFSET ; j < Constants.TOT_BLOCKS_WIDE; j++) {
				int offsetJ = j + Constants.OFFSET;
				if (!this.pitLoc(offsetJ + i*Constants.TOT_BLOCKS_WIDE))	{
					_map[i][offsetJ] = Type.FLOOR;
				}
				//System.out.println("floor");
			}
		}
	}







package Mario;

public class Map	{
	
	private Type[][] _map;
	private Type[][] _background;
	
	public Map()	{
		_map = new Type[Constants.BLOCKS_HIGH][Constants.TOT_BLOCKS_WIDE];
		_background = new Type[Constants.BLOCKS_HIGH][Constants.TOT_BLOCKS_WIDE];
		this.addBGPieces();
		this.addOthers();
		this.addFloor();
	}
	
	public void addBGPieces()	{
		int loc = 0;
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
			for (int j = 0 ; j < Constants.TOT_BLOCKS_WIDE ; j++) {
				loc = j + i*Constants.TOT_BLOCKS_WIDE;
				if (this.bgLoc(loc, i , j))	{}
				else	{
					_background[i][j] = Type.FREE;
				}
			}
		}
	}
	
	public boolean bgLoc(int loc, int i, int j)	{
		switch (loc)	{
		case 2090:
		case 2138:
		case 2186:
		case 2234:
		case 2282:
			_background[i][j] = Type.BIGHILL;
			return true;
		case 2315:
		case 2363:
		case 2412:
		case 2459:
			_background[i][j] = Type.SMALLHILL;
			return true;
		case 2310:
		case 2357:
		case 2408:
			_background[i][j] = Type.BIGBUSH;
			return true;
		case 2341:
		case 2387:
		case 2436:
			_background[i][j] = Type.MEDBUSH;
			return true;
		case 2323:
		case 2370:
		case 2418:
		case 2456:
		case 2466:
			_background[i][j] = Type.SMALLBUSH;
			return true;
		default:
			break;
		}
		return false;
	}
	
	public void addOthers()	{
		int loc = 0;
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
			for (int j = 0 ; j < Constants.TOT_BLOCKS_WIDE ; j++) {
				loc = j + i*Constants.TOT_BLOCKS_WIDE;
				if (this.brickLoc(loc))	{
					_map[i][j] = Type.BRICK;
					//System.out.println("brick");
				}
				else if (this.pitLoc(loc))	{
					_map[i][j] = Type.PIT;
				}
				else if (this.stairLoc(loc))	{
					_map[i][j] = Type.STAIR;
				}
				else if (this.mysteryLoc(loc))	{
					_map[i][j] = Type.MYSTERY;
				}
				else if (this.enemyLoc(loc, i, j))	{
					
				}
				else if (this.pipeLoc(loc, i, j))	{
					
				}
				else	{
					_map[i][j] = Type.FREE;
					//System.out.println("free");
				}
			}
		}
	}
	
	public void addFloor()	{
		for (int i = Constants.BLOCKS_HIGH-2 ; i < Constants.BLOCKS_HIGH ; i++) {
			for (int j = 0 ; j < Constants.TOT_BLOCKS_WIDE ; j++) {
				if (!this.pitLoc(j + i*Constants.TOT_BLOCKS_WIDE))	{
					_map[i][j] = Type.FLOOR;
				}
				//System.out.println("floor");
			}
		}
	}
	
	public boolean brickLoc(int loc)	{
		switch (loc)	{
		case 1692:
		case 1694:
		case 1696:
			
		case 1749:
		case 1751:
			
		case 916:
		case 917:
		case 918:
		case 919:
		case 920:
		case 921:
		case 922:
		case 923:
			
		case 927:
		case 928:
		case 929:
		case 1766:
			
		case 1772:
		case 1773:
			
		case 1790:
		case 957:
		case 958:
		case 959:
		case 964:
		case 967:
		case 1801:
		case 1802:
			
		case 1840:
		case 1841:
		case 1843:
			return true;
		default:
			break;
		}
		return false;
	}
	
	public boolean pitLoc(int loc)	{
		switch (loc)	{
		case 2577:
		case 2578:
		case 2786:
		case 2787:
			
		case 2594:
		case 2595:
		case 2596:
		case 2803:
		case 2804:
		case 2805:
			
		case 2661:
		case 2662:
		case 2870:
		case 2871:
			return true;
		default:
			break;
		}
		return false;
	}
	
	public boolean pipeLoc(int loc, int i, int j)	{
		switch (loc)	{
		case 2118: //tl
		case 1919:
		case 1718:
		case 1729:
		case 2253:
		case 2269:
			_map[i][j] = Type.PIPE_TL;
			return true;

		case 2119: //tr
		case 1920:
		case 1719:
		case 1730:
		case 2254:
		case 2270:
			_map[i][j] = Type.PIPE_TR;
			return true;
			
		case 2327: //l
		case 2128:
		case 2337:
		case 1927:
		case 2136:
		case 2345:
		case 1938:
		case 2147:
		case 2356:
		case 2462:
		case 2478:
			_map[i][j] = Type.PIPE_L;
			return true;
			
			
		case 2328: //r
		case 2129:
		case 2338:
		case 1928:
		case 2137:
		case 2346:
		case 1939:
		case 2148:
		case 2357:
		case 2463:
		case 2479:
			_map[i][j] = Type.PIPE_R;
			return true;
		default:
			break;
		}
		return false;
	}
	
	public boolean stairLoc(int loc)	{
		switch (loc)	{
		case 2433:
		case 2434:
		case 2435:
		case 2436:
		case 2439:
		case 2440:
		case 2441:
		case 2442:
		case 2225:
		case 2226:
		case 2227:
		case 2230:
		case 2231:
		case 2232:
		case 2017:
		case 2018:
		case 2021:
		case 2022:
		case 1809:
		case 1812:
			
		case 2447:
		case 2448:
		case 2449:
		case 2450:
		case 2451:
		case 2454:
		case 2455:
		case 2456:
		case 2457:
		case 2239:
		case 2240:
		case 2241:
		case 2242:
		case 2245:
		case 2246:
		case 2247:
		case 2031:
		case 2032:	
		case 2033:
		case 2036:
		case 2037:
		case 1823:
		case 1824:
		case 1827:
			
		case 2480:
		case 2481:
		case 2482:
		case 2483:
		case 2484:
		case 2485:
		case 2486:
		case 2487:
		case 2488:
			
		case 2272:
		case 2273:
		case 2274:
		case 2275:
		case 2276:
		case 2277:
		case 2278:
		case 2279:
			
		case 2064:
		case 2065:
		case 2066:
		case 2067:
		case 2068:
		case 2069:
		case 2070:
			
		case 1856:
		case 1857:
		case 1858:
		case 1859:
		case 1860:
		case 1861:
			
		case 1648:
		case 1649:
		case 1650:
		case 1651:
		case 1652:
			
		case 1440:
		case 1441:
		case 1442:
		case 1443:
			
		case 1232:
		case 1233:
		case 1234:
			
		case 1024:
		case 1025:
			return true;
		default:
			break;
		}
		return false;
	}
	
	public boolean mysteryLoc(int loc)	{
		switch (loc)	{
		case 1688:
		case 858:
		case 1693:
		case 1695:
		case 1750:
		case 930:
		case 1778:
		case 1781:
		case 1784:
		case 945:
		case 965:
		case 966:
		case 1842:
			return true;
		default:
			break;
		}
		return false;
	}
	
	public boolean enemyLoc(int loc, int i, int j)	{
		switch (loc)	{
		case 2330:
			_map[i][j] = Type.KOOPA;
			return true;
		case 2465:
			_map[i][j] = Type.KOOPA;
			return true;
		default:
			break;
		}
		return false;
	}
	
	public Type[][] getMap()	{
		return _map;
	}
	
	public Type[][] getBackground()	{
		return _background;
	}
	
}




private void shiftArray(Array[][] array)	{
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
				Square oldSquare = _squaresOnScreen[i][0];
				_gamespace.getChildren().remove(oldSquare.getBody());
				oldSquare = null;
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH; i++)	{
				for (int j = 1 ; j < Constants.BLOCKS_WIDE; j++)	{
					_squaresOnScreen[i][j-1] = _squaresOnScreen[i][j];
				}
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
				_squaresOnScreen[i][Constants.BLOCKS_WIDE-1] = 
						detNewPiece(i, Constants.BLOCKS_WIDE-1);
			}
			for (Enemy enemy : _enemies)	{
				enemy.getBody().toFront();
				enemy.updateSquaresOnScreen(_squaresOnScreen);
			}	
		}





before background array was made
package Mario;

import java.util.ArrayList;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.animation.Animation.Status;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Label;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;

public class Game	{
	
	private Pane _gamespace;
	private Timeline _timeline;
	private KeyHandler _keyEvent;
	private int _score;
	private Label _scoreTxt;
	private int _lives;
	private Label _livesTxt;
	private boolean _paused;
	private Rectangle _background;
	private Mario _mario;
	private Timeline _jumpTL;
	private Timeline _moveTL;
	private Timeline _gravity;
	private ArrayList<Label> _locs;
	private Square[][] _squaresOnScreen;
	private ArrayList<Rectangle> _bgPiecesOnScreen;
	private Line _test;
	private Type[][] _map;
	private int _colsDeleted;
	private ArrayList<Enemy> _enemies;
	
	public Game(Pane gamespace, Rectangle bg)	{
		_gamespace = gamespace;
		_background = bg;
		_keyEvent = new KeyHandler();
		_gamespace.addEventHandler(KeyEvent.KEY_PRESSED, _keyEvent);
		_gamespace.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>()	{
			@Override
			public void handle(KeyEvent event) {
				KeyCode keyPressed = event.getCode();
				switch (keyPressed)	{
				case LEFT:
					_moveTL.stop();
					break;
				case RIGHT:
					_moveTL.stop();
					break;
				default:
					break;
				}
			}
		});
		this.setupGame();
		this.setupTLs();
	}
	
	private void setupGame()	{
		this.setupMap();
//		_locs = new ArrayList<Label>();
//		for (int i = 0 ; i < Constants.BLOCKS_HIGH-2 ; i++) {
//			for (int j = 0 ; j < Constants.TOT_BLOCKS_WIDE ; j++) {
//				//if (i ==  && j == )
//				Label label = new Label(Integer.toString(j + i*Constants.TOT_BLOCKS_WIDE));
//				label.setLayoutX(j*Constants.MARIO_LENGTH);
//				label.setLayoutY(i*Constants.MARIO_LENGTH);
//				_gamespace.getChildren().add(label);
//				_locs.add(label);
//				
//			}
//		}
		_mario = new Mario(_gamespace);
	}
	
	private void setupMap()	{ //make a new generation system where only blocks on screen are loaded
		Map temp = new Map();
		_squaresOnScreen = new Square[Constants.BLOCKS_HIGH][Constants.BLOCKS_WIDE];
		_enemies = new ArrayList<Enemy>();
		_bgPiecesOnScreen = new ArrayList<Rectangle>();
		_map = temp.getMap();
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
			for (int j = 0 ; j < Constants.BLOCKS_WIDE; j++)	{ 
				_squaresOnScreen[i][j] = this.detNewPiece(i, j);
			}
		}
		for (Enemy enemy : _enemies)	{
			enemy.updateSquaresOnScreen(_squaresOnScreen);
		}
	} //i dont think i even need coords lmao
	
	private Square detNewPiece(int i, int j)	{
		Square piece = null;
		Rectangle bgPiece = null;
		MapCoordinate coord = new MapCoordinate(i,j);
		//System.out.println(_colsDeleted);
		switch (_map[i][j + _colsDeleted])	{
		case PIT:
		case FREE:
			piece = new Free(_gamespace, coord);
			break;
		case BIGHILL:
			piece = new Free(_gamespace, coord);
			bgPiece = new Rectangle(coord.getColumn()*Constants.MARIO_LENGTH, coord.getRow()*Constants.MARIO_LENGTH,
					Constants.MARIO_LENGTH*5, Constants.MARIO_LENGTH*2);
			bgPiece.setFill(Constants.BIG_HILL);
			_gamespace.getChildren().add(bgPiece);
			_bgPiecesOnScreen.add(bgPiece);
			
			break;
		case SMALLHILL:
			piece = new Free(_gamespace, coord);
			bgPiece = new Rectangle(coord.getColumn()*Constants.MARIO_LENGTH, coord.getRow()*Constants.MARIO_LENGTH,
					Constants.MARIO_LENGTH*3, Constants.MARIO_LENGTH);
			bgPiece.setFill(Constants.SMALL_HILL);
			_gamespace.getChildren().add(bgPiece);
			_bgPiecesOnScreen.add(bgPiece);
			break;
		case BIGBUSH:
			piece = new Free(_gamespace, coord);
			bgPiece = new Rectangle(coord.getColumn()*Constants.MARIO_LENGTH, coord.getRow()*Constants.MARIO_LENGTH,
					Constants.MARIO_LENGTH*5, Constants.MARIO_LENGTH);
			bgPiece.setFill(Constants.BIG_BUSH);
			_gamespace.getChildren().add(bgPiece);
			_bgPiecesOnScreen.add(bgPiece);
			break;
		case MEDBUSH:
			piece = new Free(_gamespace, coord);
			bgPiece = new Rectangle(coord.getColumn()*Constants.MARIO_LENGTH, coord.getRow()*Constants.MARIO_LENGTH,
					Constants.MARIO_LENGTH*4, Constants.MARIO_LENGTH);
			bgPiece.setFill(Constants.MED_BUSH);
			_gamespace.getChildren().add(bgPiece);
			_bgPiecesOnScreen.add(bgPiece);
			break;
		case SMALLBUSH:
			piece = new Free(_gamespace, coord);
			bgPiece = new Rectangle(coord.getColumn()*Constants.MARIO_LENGTH, coord.getRow()*Constants.MARIO_LENGTH,
					Constants.MARIO_LENGTH*3, Constants.MARIO_LENGTH);
			bgPiece.setFill(Constants.SMALL_BUSH);
			_gamespace.getChildren().add(bgPiece);
			_bgPiecesOnScreen.add(bgPiece);
			break;
		case GOOMBA:
			piece = new Free(_gamespace, coord);
			_enemies.add(new Goomba(_gamespace, coord));
			break;
		case KOOPA:
			piece = new Free(_gamespace, coord);
			_enemies.add(new Koopa(_gamespace, coord));
			break;
		case FLOOR:
			piece = new Floor(_gamespace, coord);
			break;
		case BRICK:
			piece = new Brick(_gamespace, coord);
			break;
		case PIPE_TL:
			piece = new Pipe(_gamespace, coord, Type.PIPE_TL);
			break;
		case PIPE_TR:
			piece = new Pipe(_gamespace, coord, Type.PIPE_TR);
			break;
		case PIPE_L:
			piece = new Pipe(_gamespace, coord, Type.PIPE_L);
			break;
		case PIPE_R:
			piece = new Pipe(_gamespace, coord, Type.PIPE_R);
			break;
		case STAIR:
			piece = new Stair(_gamespace, coord);
			break;
		case MYSTERY:
			piece = new Mystery(_gamespace, coord, true);
			break;
		default:
			break;
		}
		return piece;
	}
	
	private void setupTLs()	{
		_jumpTL = new Timeline();
		_jumpTL.setCycleCount(Animation.INDEFINITE);
		KeyFrame jump = new KeyFrame(Duration.seconds(Constants.DURATION), new Jump());
		_jumpTL.getKeyFrames().add(jump);
		
		_moveTL = new Timeline();
		_moveTL.setCycleCount(Animation.INDEFINITE);
		KeyFrame move = new KeyFrame(Duration.seconds(Constants.DURATION/8), new Move());
		_moveTL.getKeyFrames().add(move);
		
		_test = new Line(0,0,0,0);
	}
	
	private Square checkNextBlockForJump(double newX, double newY)	{
		_test.setStartX(newX);
		_test.setEndX(newX + Constants.MARIO_LENGTH);
		_test.setStartY(newY);
		_test.setEndY(newY);
		for (Square[] squares : _squaresOnScreen)	{
			for (Square square : squares)	{
				if (square.getBody().intersects(_test.getBoundsInLocal())
						&& square.getSolid()) {
					return square;
				}
			}
		}
		return null;
	}
	
	private Square checkNextBlockForMove(double newX, double newY)	{
		int weight3 = 0;
		if (_mario.getDir() == Direction.RIGHT) {
			weight3 = 1;
		}
		_test.setStartX(newX + Constants.MARIO_LENGTH*weight3);
		_test.setEndX(newX + Constants.MARIO_LENGTH*weight3);
		_test.setStartY(newY);
		_test.setEndY(newY + Constants.MARIO_LENGTH);
		_gamespace.getChildren().add(_test);
		for (Square[] squares : _squaresOnScreen)	{
			for (Square square : squares)	{
				if (square.getBody().intersects(_test.getBoundsInLocal())
						&& square.getSolid()) {
					return square;
				}
			}
		}
		return null;
	}

	private class KeyHandler implements EventHandler<KeyEvent>	{
		
		public KeyHandler()	{}
		
		@Override
		public void handle(KeyEvent event)	{
			KeyCode keyPressed = event.getCode();
			switch (keyPressed)	{
			case LEFT:
				_mario.setDir(Direction.LEFT);
				_moveTL.play();
				break;
			case RIGHT:
				_mario.setDir(Direction.RIGHT);
				_moveTL.play();
				break;
			case SPACE:
				if (_jumpTL.getStatus() == Status.STOPPED) {
					_jumpTL.stop();
					_jumpTL.play();
				}
				break;
			case DOWN:
				break;
			case P:
				if (_paused)	{
					_timeline.play();
					_paused = false;
				}
				else	{
					_timeline.pause();
					_paused = true;
				}
				break;
			case Q:
				Platform.exit();
				break;
			default:
				break;
			}
			
			event.consume();
		}
	}
	
	
	private class Jump implements EventHandler<ActionEvent>	{
		
		public Jump()	{
			_mario.setVelocity(Constants.INIT_V);
		}
		
		@Override
        public void handle(ActionEvent e) {
			_mario.updateVelocity();
			double newY = _mario.getBody().getY() + _mario.getVelocity() * Constants.DURATION;
			Square nextBlock = null;
			if (_mario.getVelocity() > 0)	{
				nextBlock = checkNextBlockForJump(_mario.getBody().getX(), newY + Constants.MARIO_LENGTH);
				for (Enemy enemy : _enemies)	{
					if (enemy.getBody().intersects(new Line(_mario.getBody().getX(), _mario.getBody().getY() + Constants.MARIO_LENGTH + 1, 
							_mario.getBody().getX() + Constants.MARIO_LENGTH, _mario.getBody().getY() + Constants.MARIO_LENGTH + 1).getBoundsInLocal()))	{
						this.detEnemyAction(enemy);
						_mario.setVelocity(Constants.INIT_V);
					}
				}
				if (nextBlock != null)	{
					_mario.setVelocity(Constants.INIT_V);
					_mario.getBody().setY(nextBlock.getBody().getY() - Constants.MARIO_LENGTH - 1);
					_jumpTL.stop();
				}
				else	{ 
					_mario.getBody().setY(newY);
				}
			}
			else if (_mario.getVelocity() <= 0)	{
				nextBlock = checkNextBlockForJump(_mario.getBody().getX(), newY);
				if (nextBlock != null)	{
					//System.out.print(nextBlock.getType());
					_mario.setVelocity(_mario.getVelocity()*-1);
					_mario.getBody().setY(nextBlock.getBody().getY() + Constants.MARIO_LENGTH + 1);
					this.detBlockAction(nextBlock);
					//_mario.getBody().setY(_mario.getBody().getY() + _mario.getVelocity() * Constants.DURATION);
				}
				else	{
					_mario.getBody().setY(newY);
				}
			}
			if (_mario.getBody().getY() > Constants.GAME_HEIGHT)	{
				Platform.exit();
			}
			
			e.consume();
        }
		
		private void detBlockAction(Square block)	{
			switch (block.getType())	{
			case BRICK:
				block.delete();
				break;
			case MYSTERY:
				block.delete();
				break;
			default:
				break;
			}
		}
		
		private void detEnemyAction(Enemy enemy)	{
			switch (enemy.getType())	{
			case GOOMBA:
				enemy.getBody().setHeight(Constants.MARIO_LENGTH/2);
				enemy.getBody().setY(enemy.getBody().getY() + Constants.MARIO_LENGTH/2);
				enemy.getBody().setFill(Constants.GOOMBA_SQUISHED);
				break;
			case KOOPA:
				enemy.getBody().setFill(Constants.KOOPA_SHELL);
				break;
			default:
				break;
			}
		}
		
	}
	
	private class Move implements EventHandler<ActionEvent>	{
		
		public Move()	{}
	
		@Override
        public void handle(ActionEvent e) {
			_gamespace.getChildren().remove(_test);
			if (checkNextBlockForJump(_mario.getBody().getX(), _mario.getBody().getY() + 1 + Constants.MARIO_LENGTH) == null
					&& _jumpTL.getStatus() == Status.STOPPED)	{
				_mario.setVelocity(0);
				_jumpTL.play();
			}
			if (checkNextBlockForMove(_mario.getBody().getX() + _mario.getDir().distance()*Constants.DISPLACEMENT, _mario.getBody().getY()) == null) {
				if (_mario.getBody().getX() + Constants.DISPLACEMENT >= Constants.MAX_X
						&& _colsDeleted < Constants.TOT_BLOCKS_WIDE - Constants.BLOCKS_WIDE) {
//					for (Label l : _locs) {
//						l.setLayoutX(l.getLayoutX()-Constants.DISPLACEMENT);
//					}
					for (Square[] squares : _squaresOnScreen)	{
						for (Square square : squares)	{
							square.setX(square.getBody().getX() - Constants.DISPLACEMENT);
						}
					}
					this.adjustBG();
					for (Enemy enemy : _enemies)	{
						enemy.getBody().setX(enemy.getBody().getX() - Constants.DISPLACEMENT);
					}
					if (_squaresOnScreen[0][0].getBody().getX() < -Constants.MARIO_LENGTH+Constants.DISPLACEMENT) {
						//_squaresOnScreen.remove(square);
						this.shiftArray();
						_mario.getBody().toFront();
						if (_colsDeleted!=Constants.TOT_BLOCKS_WIDE)	{
							_colsDeleted++;
						}
						//square = null;
					}
				}
				_mario.move();
			}
			e.consume();
        }
		
		
		private void shiftArray()	{
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
				Square oldSquare = _squaresOnScreen[i][0];
				_gamespace.getChildren().remove(oldSquare.getBody());
				oldSquare = null;
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH; i++)	{
				for (int j = 1 ; j < Constants.BLOCKS_WIDE; j++)	{
					_squaresOnScreen[i][j-1] = _squaresOnScreen[i][j];
				}
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
				_squaresOnScreen[i][Constants.BLOCKS_WIDE-1] = 
						detNewPiece(i, Constants.BLOCKS_WIDE-1);
			}
			for (Enemy enemy : _enemies)	{
				enemy.getBody().toFront();
				enemy.updateSquaresOnScreen(_squaresOnScreen);
			}	
		}
		
		private void adjustBG()	{
			ArrayList<Rectangle> remove = new ArrayList<Rectangle>();
			for (Rectangle bg : _bgPiecesOnScreen)	{
				bg.setX(bg.getX() - Constants.DISPLACEMENT);
				if (bg.getX() < -1 * bg.getWidth())	{
					remove.add(bg);
				}
			}
			for (Rectangle removeable : remove)	{
				_gamespace.getChildren().remove(removeable);
				_bgPiecesOnScreen.remove(removeable);
			}
		}
	}
	
}






VVVVVidk about this

package Mario;

import java.util.ArrayList;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.animation.Animation.Status;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Label;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;

public class Game	{
	
	private Pane _gamespace;
	private Timeline _timeline;
	private KeyHandler _keyEvent;
	private int _score;
	private Label _scoreTxt;
	private int _lives;
	private Label _livesTxt;
	private boolean _paused;
	private Rectangle _background;
	private Mario _mario;
	private Timeline _jumpTL;
	private Timeline _moveTL;
	private Timeline _gravity;
	private ArrayList<Label> _locs;
	private Square[][] _squaresOnScreen;
	private Rectangle[][] _bgPiecesOnScreen;
	private Line _test;
	private Type[][] _map;
	private int _colsDeleted;
	private ArrayList<Enemy> _enemies;
	private Type[][] _backgroundMap;
	
	public Game(Pane gamespace, Rectangle bg)	{
		_gamespace = gamespace;
		_background = bg;
		_keyEvent = new KeyHandler();
		_gamespace.addEventHandler(KeyEvent.KEY_PRESSED, _keyEvent);
		_gamespace.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>()	{
			@Override
			public void handle(KeyEvent event) {
				KeyCode keyPressed = event.getCode();
				switch (keyPressed)	{
				case LEFT:
					_moveTL.stop();
					break;
				case RIGHT:
					_moveTL.stop();
					break;
				default:
					break;
				}
			}
		});
		this.setupGame();
		this.setupTLs();
	}
	
	private void setupGame()	{
		this.setupMap();
//		_locs = new ArrayList<Label>();
//		for (int i = 0 ; i < Constants.BLOCKS_HIGH-2 ; i++) {
//			for (int j = 0 ; j < Constants.TOT_BLOCKS_WIDE ; j++) {
//				//if (i ==  && j == )
//				Label label = new Label(Integer.toString(j + i*Constants.TOT_BLOCKS_WIDE));
//				label.setLayoutX(j*Constants.MARIO_LENGTH);
//				label.setLayoutY(i*Constants.MARIO_LENGTH);
//				_gamespace.getChildren().add(label);
//				_locs.add(label);
//				
//			}
//		}
		_mario = new Mario(_gamespace);
	}
	
	private void setupMap()	{ //make a new generation system where only blocks on screen are loaded
		Map temp = new Map();
		_squaresOnScreen = new Square[Constants.BLOCKS_HIGH][Constants.BLOCKS_WIDE];
		_enemies = new ArrayList<Enemy>();
		_bgPiecesOnScreen = new Rectangle[Constants.BLOCKS_HIGH][Constants.BLOCKS_WIDE];
		_map = temp.getMap();
		_backgroundMap = temp.getBackground();
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
			for (int j = 0 ; j < Constants.BLOCKS_WIDE; j++)	{ 
				_squaresOnScreen[i][j] = this.detNewPiece(i, j);
				_bgPiecesOnScreen[i][j] = this.detNewBGPiece(i, j);
			}
		}
		for (Enemy enemy : _enemies)	{
			enemy.updateSquaresOnScreen(_squaresOnScreen);
		}
	} //i dont think i even need coords lmao
	
	private Rectangle detNewBGPiece(int i, int j)	{
		Rectangle bgPiece = null;
		MapCoordinate coord = new MapCoordinate(i,j);
		switch (_backgroundMap[i][j + _colsDeleted])	{
		case BIGHILL:
			bgPiece = new Rectangle(coord.getColumn()*Constants.MARIO_LENGTH, coord.getRow()*Constants.MARIO_LENGTH,
					Constants.MARIO_LENGTH*5, Constants.MARIO_LENGTH*2);
			bgPiece.setFill(Constants.BIG_HILL);
			_gamespace.getChildren().add(bgPiece);
			
			break;
		case SMALLHILL:
			bgPiece = new Rectangle(coord.getColumn()*Constants.MARIO_LENGTH, coord.getRow()*Constants.MARIO_LENGTH,
					Constants.MARIO_LENGTH*3, Constants.MARIO_LENGTH);
			bgPiece.setFill(Constants.SMALL_HILL);
			_gamespace.getChildren().add(bgPiece);
			break;
		case BIGBUSH:
			bgPiece = new Rectangle(coord.getColumn()*Constants.MARIO_LENGTH, coord.getRow()*Constants.MARIO_LENGTH,
					Constants.MARIO_LENGTH*5, Constants.MARIO_LENGTH);
			bgPiece.setFill(Constants.BIG_BUSH);
			_gamespace.getChildren().add(bgPiece);
			break;
		case MEDBUSH:
			bgPiece = new Rectangle(coord.getColumn()*Constants.MARIO_LENGTH, coord.getRow()*Constants.MARIO_LENGTH,
					Constants.MARIO_LENGTH*4, Constants.MARIO_LENGTH);
			bgPiece.setFill(Constants.MED_BUSH);
			_gamespace.getChildren().add(bgPiece);
			break;
		case SMALLBUSH:
			bgPiece = new Rectangle(coord.getColumn()*Constants.MARIO_LENGTH, coord.getRow()*Constants.MARIO_LENGTH,
					Constants.MARIO_LENGTH*3, Constants.MARIO_LENGTH);
			bgPiece.setFill(Constants.SMALL_BUSH);
			_gamespace.getChildren().add(bgPiece);
			break;
		default:
			break;
		}
		return bgPiece;
	}
	
	private Square detNewPiece(int i, int j)	{
		Square piece = null;
		MapCoordinate coord = new MapCoordinate(i,j);
		//System.out.println(_colsDeleted);
		switch (_map[i][j + _colsDeleted])	{
		case PIT:
		case FREE:
			piece = new Free(_gamespace, coord);
			break;
		case GOOMBA:
			piece = new Free(_gamespace, coord);
			_enemies.add(new Goomba(_gamespace, coord));
			break;
		case KOOPA:
			piece = new Free(_gamespace, coord);
			_enemies.add(new Koopa(_gamespace, coord));
			break;
		case FLOOR:
			piece = new Floor(_gamespace, coord);
			break;
		case BRICK:
			piece = new Brick(_gamespace, coord);
			break;
		case PIPE_TL:
			piece = new Pipe(_gamespace, coord, Type.PIPE_TL);
			break;
		case PIPE_TR:
			piece = new Pipe(_gamespace, coord, Type.PIPE_TR);
			break;
		case PIPE_L:
			piece = new Pipe(_gamespace, coord, Type.PIPE_L);
			break;
		case PIPE_R:
			piece = new Pipe(_gamespace, coord, Type.PIPE_R);
			break;
		case STAIR:
			piece = new Stair(_gamespace, coord);
			break;
		case MYSTERY:
			piece = new Mystery(_gamespace, coord, true);
			break;
		default:
			break;
		}
		return piece;
	}
	
	private void setupTLs()	{
		_jumpTL = new Timeline();
		_jumpTL.setCycleCount(Animation.INDEFINITE);
		KeyFrame jump = new KeyFrame(Duration.seconds(Constants.DURATION), new Jump());
		_jumpTL.getKeyFrames().add(jump);
		
		_moveTL = new Timeline();
		_moveTL.setCycleCount(Animation.INDEFINITE);
		KeyFrame move = new KeyFrame(Duration.seconds(Constants.DURATION/8), new Move());
		_moveTL.getKeyFrames().add(move);
		
		_test = new Line(0,0,0,0);
	}
	
	private Square checkNextBlockForJump(double newX, double newY)	{
		_test.setStartX(newX);
		_test.setEndX(newX + Constants.MARIO_LENGTH);
		_test.setStartY(newY);
		_test.setEndY(newY);
		for (Square[] squares : _squaresOnScreen)	{
			for (Square square : squares)	{
				if (square.getBody().intersects(_test.getBoundsInLocal())
						&& square.getSolid()) {
					return square;
				}
			}
		}
		return null;
	}
	
	private Square checkNextBlockForMove(double newX, double newY)	{
		int weight3 = 0;
		if (_mario.getDir() == Direction.RIGHT) {
			weight3 = 1;
		}
		_test.setStartX(newX + Constants.MARIO_LENGTH*weight3);
		_test.setEndX(newX + Constants.MARIO_LENGTH*weight3);
		_test.setStartY(newY);
		_test.setEndY(newY + Constants.MARIO_LENGTH);
		_gamespace.getChildren().add(_test);
		for (Square[] squares : _squaresOnScreen)	{
			for (Square square : squares)	{
				if (square.getBody().intersects(_test.getBoundsInLocal())
						&& square.getSolid()) {
					return square;
				}
			}
		}
		return null;
	}

	private class KeyHandler implements EventHandler<KeyEvent>	{
		
		public KeyHandler()	{}
		
		@Override
		public void handle(KeyEvent event)	{
			KeyCode keyPressed = event.getCode();
			switch (keyPressed)	{
			case LEFT:
				_mario.setDir(Direction.LEFT);
				_moveTL.play();
				break;
			case RIGHT:
				_mario.setDir(Direction.RIGHT);
				_moveTL.play();
				break;
			case SPACE:
				if (_jumpTL.getStatus() == Status.STOPPED) {
					_jumpTL.stop();
					_jumpTL.play();
				}
				break;
			case DOWN:
				break;
			case P:
				if (_paused)	{
					_timeline.play();
					_paused = false;
				}
				else	{
					_timeline.pause();
					_paused = true;
				}
				break;
			case Q:
				Platform.exit();
				break;
			default:
				break;
			}
			
			event.consume();
		}
	}
	
	
	private class Jump implements EventHandler<ActionEvent>	{
		
		public Jump()	{
			_mario.setVelocity(Constants.INIT_V);
		}
		
		@Override
        public void handle(ActionEvent e) {
			_mario.updateVelocity();
			double newY = _mario.getBody().getY() + _mario.getVelocity() * Constants.DURATION;
			Square nextBlock = null;
			if (_mario.getVelocity() > 0)	{
				nextBlock = checkNextBlockForJump(_mario.getBody().getX(), newY + Constants.MARIO_LENGTH);
				for (Enemy enemy : _enemies)	{
					if (enemy.getBody().intersects(new Line(_mario.getBody().getX(), _mario.getBody().getY() + Constants.MARIO_LENGTH + 1, 
							_mario.getBody().getX() + Constants.MARIO_LENGTH, _mario.getBody().getY() + Constants.MARIO_LENGTH + 1).getBoundsInLocal()))	{
						this.detEnemyAction(enemy);
						_mario.setVelocity(Constants.INIT_V);
					}
				}
				if (nextBlock != null)	{
					_mario.setVelocity(Constants.INIT_V);
					_mario.getBody().setY(nextBlock.getBody().getY() - Constants.MARIO_LENGTH - 1);
					_jumpTL.stop();
				}
				else	{ 
					_mario.getBody().setY(newY);
				}
			}
			else if (_mario.getVelocity() <= 0)	{
				nextBlock = checkNextBlockForJump(_mario.getBody().getX(), newY);
				if (nextBlock != null)	{
					//System.out.print(nextBlock.getType());
					_mario.setVelocity(_mario.getVelocity()*-1);
					_mario.getBody().setY(nextBlock.getBody().getY() + Constants.MARIO_LENGTH + 1);
					this.detBlockAction(nextBlock);
					//_mario.getBody().setY(_mario.getBody().getY() + _mario.getVelocity() * Constants.DURATION);
				}
				else	{
					_mario.getBody().setY(newY);
				}
			}
			if (_mario.getBody().getY() > Constants.GAME_HEIGHT)	{
				Platform.exit();
			}
			
			e.consume();
        }
		
		private void detBlockAction(Square block)	{
			switch (block.getType())	{
			case BRICK:
				block.delete();
				break;
			case MYSTERY:
				block.delete();
				break;
			default:
				break;
			}
		}
		
		private void detEnemyAction(Enemy enemy)	{
			switch (enemy.getType())	{
			case GOOMBA:
				enemy.getBody().setHeight(Constants.MARIO_LENGTH/2);
				enemy.getBody().setY(enemy.getBody().getY() + Constants.MARIO_LENGTH/2);
				enemy.getBody().setFill(Constants.GOOMBA_SQUISHED);
				break;
			case KOOPA:
				enemy.getBody().setFill(Constants.KOOPA_SHELL);
				break;
			default:
				break;
			}
		}
		
	}
	
	private class Move implements EventHandler<ActionEvent>	{
		
		public Move()	{}
	
		@Override
        public void handle(ActionEvent e) {
			_gamespace.getChildren().remove(_test);
			if (checkNextBlockForJump(_mario.getBody().getX(), _mario.getBody().getY() + 1 + Constants.MARIO_LENGTH) == null
					&& _jumpTL.getStatus() == Status.STOPPED)	{
				_mario.setVelocity(0);
				_jumpTL.play();
			}
			if (checkNextBlockForMove(_mario.getBody().getX() + _mario.getDir().distance()*Constants.DISPLACEMENT, _mario.getBody().getY()) == null) {
				if (_mario.getBody().getX() + Constants.DISPLACEMENT >= Constants.MAX_X
						&& _colsDeleted < Constants.TOT_BLOCKS_WIDE - Constants.BLOCKS_WIDE) {
//					for (Label l : _locs) {
//						l.setLayoutX(l.getLayoutX()-Constants.DISPLACEMENT);
//					}
					for (Square[] squares : _squaresOnScreen)	{
						for (Square square : squares)	{
							square.setX(square.getBody().getX() - Constants.DISPLACEMENT);
						}
					}
					this.adjustBG();
					for (Enemy enemy : _enemies)	{
						enemy.getBody().setX(enemy.getBody().getX() - Constants.DISPLACEMENT);
					}
					if (_squaresOnScreen[0][0].getBody().getX() < -Constants.MARIO_LENGTH+Constants.DISPLACEMENT) {
						//_squaresOnScreen.remove(square);
						this.shiftArray();
						_mario.getBody().toFront();
						if (_colsDeleted!=Constants.TOT_BLOCKS_WIDE)	{
							_colsDeleted++;
						}
						//square = null;
					}
				}
				_mario.move();
			}
			e.consume();
        }
		
		
		private void shiftArray()	{
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
				Square oldSquare = _squaresOnScreen[i][0];
				_gamespace.getChildren().remove(oldSquare.getBody());
				oldSquare = null;
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH; i++)	{
				for (int j = 1 ; j < Constants.BLOCKS_WIDE; j++)	{
					_squaresOnScreen[i][j-1] = _squaresOnScreen[i][j];
				}
			}
			for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
				_squaresOnScreen[i][Constants.BLOCKS_WIDE-1] = 
						detNewPiece(i, Constants.BLOCKS_WIDE-1);
			}
			for (Enemy enemy : _enemies)	{
				enemy.getBody().toFront();
				enemy.updateSquaresOnScreen(_squaresOnScreen);
			}	
		}
		
		private void adjustBG()	{
			for (Rectangle[] bgs : _bgPiecesOnScreen)	{
				for (Rectangle bg : bgs)	{
					bg.setX(bg.getX() - Constants.DISPLACEMENT);
					if (bg.getX() < -1 * bg.getWidth())	{
						_gamespace.getChildren().remove(bg);
						
					}
				}
			}
			for (Rectangle removeable : remove)	{
				_gamespace.getChildren().remove(removeable);
				_bgPiecesOnScreen.remove(removeable);
			}
		}
	}
	
}








VVVVVbefore setup overhaul

package Mario;

import java.util.ArrayList;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.animation.Animation.Status;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Label;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;

public class Game	{
	
	private Pane _gamespace;
	private Timeline _timeline;
	private KeyHandler _keyEvent;
	private int _score;
	private Label _scoreTxt;
	private int _lives;
	private Label _livesTxt;
	private boolean _paused;
	private Rectangle _background;
	private Mario _mario;
	private Timeline _jumpTL;
	private Timeline _moveTL;
	private Timeline _gravity;
	private ArrayList<Label> _locs;
	private ArrayList<Square> _squares;
	private ArrayList<Square> _squaresOnScreen;
	private Line _test;
	
	public Game(Pane gamespace, Rectangle bg)	{
		_gamespace = gamespace;
		_background = bg;
		_keyEvent = new KeyHandler();
		_gamespace.addEventHandler(KeyEvent.KEY_PRESSED, _keyEvent);
		_gamespace.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>()	{
			@Override
			public void handle(KeyEvent event) {
				KeyCode keyPressed = event.getCode();
				switch (keyPressed)	{
				case LEFT:
					_moveTL.stop();
					break;
				case RIGHT:
					_moveTL.stop();
					break;
				default:
					break;
				}
			}
		});
		this.setupGame();
		this.setupTLs();
	}
	
	private void setupGame()	{
		this.setupMap();
//		_locs = new ArrayList<Label>();
//		for (int i = 0 ; i < Constants.BLOCKS_HIGH-2 ; i++) {
//			for (int j = 0 ; j < Constants.BLOCKS_WIDE ; j++) {
//				//if (i ==  && j == )
//				Label label = new Label(Integer.toString(j + i*Constants.BLOCKS_WIDE));
//				label.setLayoutX(j*Constants.MARIO_LENGTH);
//				label.setLayoutY(i*Constants.MARIO_LENGTH);
//				_gamespace.getChildren().add(label);
//				_locs.add(label);
//				
//			}
//		}
		_mario = new Mario(_gamespace);
	}
	
	private void setupMap()	{ //make a new generation system where only blocks on screen are loaded
		Map temp = new Map();
		_squares = new ArrayList<Square>();
		_squaresOnScreen = new ArrayList<Square>();
		Type[][] map = temp.getMap();
		Square piece = null;
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
			for (int j = 0 ; j < Constants.BLOCKS_WIDE ; j++)	{
				MapCoordinate coord = new MapCoordinate(i,j);
				switch (map[i][j])	{
				case PIT:
				case FREE:
					piece = new Free(_gamespace, coord);
					_squares.add(piece);
					break;
				case FLOOR:
					piece = new Floor(_gamespace, coord);
					_squares.add(piece);
					break;
				case BRICK:
					piece = new Brick(_gamespace, coord);
					_squares.add(piece);
					break;
				case PIPE_TL:
					piece = new Pipe(_gamespace, coord, Constants.PIPE_TL);
					_squares.add(piece);
					break;
				case PIPE_TR:
					piece = new Pipe(_gamespace, coord, Constants.PIPE_TR);
					_squares.add(piece);
					break;
				case PIPE_L:
					piece = new Pipe(_gamespace, coord, Constants.PIPE_L);
					_squares.add(piece);
					break;
				case PIPE_R:
					piece = new Pipe(_gamespace, coord, Constants.PIPE_R);
					_squares.add(piece);
					break;
				case STAIR:
					piece = new Stair(_gamespace, coord);
					_squares.add(piece);
					break;
				case MYSTERY:
					piece = new Mystery(_gamespace, coord);
					_squares.add(piece);
				default:
					break;
				}
				_gamespace.getChildren().add(piece.getBody());
				if (j < 19)	{
					_squaresOnScreen.add(piece);
				}
			}
		}
	}
	
	private void setupTLs()	{
		_jumpTL = new Timeline();
		_jumpTL.setCycleCount(Animation.INDEFINITE);
		KeyFrame jump = new KeyFrame(Duration.seconds(Constants.DURATION), new Jump());
		_jumpTL.getKeyFrames().add(jump);
		
		_moveTL = new Timeline();
		_moveTL.setCycleCount(Animation.INDEFINITE);
		KeyFrame move = new KeyFrame(Duration.seconds(Constants.DURATION/8), new Move());
		_moveTL.getKeyFrames().add(move);
		
		_test = new Line(0,0,0,0);
	}
	
	private Square checkNextBlockForJump(double newX, double newY)	{
		_test.setStartX(newX);
		_test.setEndX(newX + Constants.MARIO_LENGTH);
		_test.setStartY(newY);
		_test.setEndY(newY);
		for (Square block : _squaresOnScreen)	{
			if (block.getBody().intersects(_test.getBoundsInLocal())
					&& block.getSolid()) {
				return block;
			}
		}
		return null;
	}
	
	private Square checkNextBlockForMove(double newX, double newY)	{
		int weight3 = 0;
		if (_mario.getDir() == Direction.RIGHT) {
			weight3 = 1;
		}
		_test.setStartX(newX + Constants.MARIO_LENGTH*weight3);
		_test.setEndX(newX + Constants.MARIO_LENGTH*weight3);
		_test.setStartY(newY);
		_test.setEndY(newY + Constants.MARIO_LENGTH);
		_gamespace.getChildren().add(_test);
		for (Square block : _squaresOnScreen)	{
			if (block.getBody().intersects(_test.getBoundsInLocal())
					&& block.getSolid()) {
				return block;
			}
		}
		return null;
	}

	private class KeyHandler implements EventHandler<KeyEvent>	{
		
		public KeyHandler()	{}
		
		@Override
		public void handle(KeyEvent event)	{
			KeyCode keyPressed = event.getCode();
			switch (keyPressed)	{
			case LEFT:
				_mario.setDir(Direction.LEFT);
				_moveTL.play();
				break;
			case RIGHT:
				_mario.setDir(Direction.RIGHT);
				_moveTL.play();
				break;
			case SPACE:
				if (_jumpTL.getStatus() == Status.STOPPED) {
					_jumpTL.stop();
					_jumpTL.play();
				}
				break;
			case DOWN:
				break;
			case P:
				if (_paused)	{
					_timeline.play();
					_paused = false;
				}
				else	{
					_timeline.pause();
					_paused = true;
				}
				break;
			case Q:
				Platform.exit();
				break;
			default:
				break;
			}
			
			event.consume();
		}
	}
	
	
	private class Jump implements EventHandler<ActionEvent>	{
		
		public Jump()	{
			_mario.setVelocity(Constants.INIT_V);
		}
		
		@Override
        public void handle(ActionEvent e) {
			_mario.updateVelocity();
			double newY = _mario.getBody().getY() + _mario.getVelocity() * Constants.DURATION;
			Square nextBlock = null;
			if (_mario.getVelocity() > 0)	{
				nextBlock = checkNextBlockForJump(_mario.getBody().getX(), newY + Constants.MARIO_LENGTH);
				if (nextBlock != null)	{
					_mario.setVelocity(Constants.INIT_V);
					_mario.getBody().setY(nextBlock.getBody().getY() - Constants.MARIO_LENGTH - 1);
					_jumpTL.stop();
				}
				else	{ 
					_mario.getBody().setY(newY);
				}
			}
			else if (_mario.getVelocity() <= 0)	{
				nextBlock = checkNextBlockForJump(_mario.getBody().getX(), newY);
				if (nextBlock != null)	{
					System.out.print(nextBlock.getType());
					_mario.setVelocity(_mario.getVelocity()*-1);
					_mario.getBody().setY(nextBlock.getBody().getY() + Constants.MARIO_LENGTH + 1);
					this.detBlockAction(nextBlock);
					//_mario.getBody().setY(_mario.getBody().getY() + _mario.getVelocity() * Constants.DURATION);
				}
				else	{
					_mario.getBody().setY(newY);
				}
			}
			
			e.consume();
        }
		
		private void detBlockAction(Square block)	{
			switch (block.getType())	{
			case BRICK:
				block.delete();
				break;
			case MYSTERY:
				block.delete();
			default:
				break;
			}
		}
		
	}
	
	private class Move implements EventHandler<ActionEvent>	{
		
		public Move()	{}
	
		@Override
        public void handle(ActionEvent e) {
			_gamespace.getChildren().remove(_test);
			if (checkNextBlockForJump(_mario.getBody().getX(), _mario.getBody().getY() + 1 + Constants.MARIO_LENGTH) == null
					&& _jumpTL.getStatus() == Status.STOPPED)	{
				_mario.setVelocity(0);
				_jumpTL.play();
			}
			if (checkNextBlockForMove(_mario.getBody().getX() + _mario.getDir().distance()*Constants.DISPLACEMENT, _mario.getBody().getY()) == null) {
				_mario.move();
				if (_mario.getBody().getX() + Constants.DISPLACEMENT >= Constants.MAX_X
						&& _squares.get(_squares.size()-1).getBody().getX() + Constants.DISPLACEMENT >= Constants.GAME_WIDTH) {
					for (Square square : _squares)	{
						square.getBody().setX(square.getBody().getX() - Constants.DISPLACEMENT);
						if (_squaresOnScreen.contains(square) && square.getBody().getX() < 0) {
							_squaresOnScreen.remove(square);
							//_gamespace.getChildren().remove(square.getBody());
						}
						else if (!_squaresOnScreen.contains(square) && square.getBody().getX() < Constants.GAME_WIDTH)	{
							_squaresOnScreen.add(square);
							//_gamespace.getChildren().add(square.getBody());
						}
					}
				}
			}
//				if (_mario.getBody().getX() + Constants.DISPLACEMENT >= Constants.MAX_X
//					  && _background.getX() >= Constants.GAME_WIDTH*-13.9)	{
//						_background.setX(_background.getX() - Constants.DISPLACEMENT);
//						for (Label l : _locs) {
//							l.setLayoutX(l.getLayoutX()-Constants.DISPLACEMENT);
//						}
//				}
			e.consume();
        }
		
	}
	
}


private Square checkNextBlockForJump(double newX, double newY)	{
		//_gamespace.getChildren().remove(_test);
		_test = new Line(newX, newY, newX + Constants.MARIO_LENGTH, newY);
		//_test.setStrokeWidth(4);
		//_gamespace.getChildren().add(_test);
		for (Square block : _squaresOnScreen)	{
			if (block.getBody().intersects(_test.getBoundsInLocal())
					&& block.getSolid()) {
				return block;
			}
		}
		return null;
	}
	
	private Square checkNextBlockForMove(double newX, double newY)	{
		int weight3 = 0;
		if (_mario.getDir() == Direction.RIGHT) {
			weight3 = 1;
		}
		//_gamespace.getChildren().remove(_test);
		_test = new Line(newX + Constants.MARIO_LENGTH*weight3, newY, newX + Constants.MARIO_LENGTH*weight3, newY + Constants.MARIO_LENGTH);
		
		//_test.setStrokeWidth(4);
		_gamespace.getChildren().add(_test);
		for (Square block : _squaresOnScreen)	{
			if (block.getBody().intersects(_test.getBoundsInLocal())
					&& block.getSolid()) {
				return block;
			}
		}
		return null;
	}
	
	
	
	
	private Square checkNextBlock(double newX, double newY, boolean horizontal, boolean vertical)	{
		int weight1 = 0;
		int weight2 = 0;
		int weight3 = 0;
		if (horizontal)	{
			weight1 = 1;
		}
		else if (vertical)	{
			weight2 = 1;
		}
		if (_mario.getDir() == Direction.RIGHT) {
			weight1 ++;
			weight3 = 1;
		}
		_gamespace.getChildren().remove(_test);
		_test = new Line(newX + Constants.MARIO_LENGTH*weight3, newY, newX + Constants.MARIO_LENGTH*weight1, newY + Constants.MARIO_LENGTH*weight2);
		_test.setStrokeWidth(4);
		_gamespace.getChildren().add(_test);
		for (Square block : _squaresOnScreen)	{
			if (block.getBody().intersects(_test.getBoundsInLocal())
					&& block.getSolid()) {
				return block;
			}
		}
		return null;
	}



private boolean checkNextBlock(double newX)	{
		for (Square block : _squaresOnScreen)	{
			if (block.getSolid() && block.getBody().intersects
					(new Rectangle(newX, _mario.getBody().getY(),
							Constants.MARIO_LENGTH, Constants.MARIO_LENGTH).getBoundsInLocal())) {
				System.out.println("intersecting");
				System.out.println(block.getType());
				return true;
			}
			if (!block.getSolid() && block.getBody().intersects
					(new Rectangle(newX, _mario.getBody().getY()+1,
							Constants.MARIO_LENGTH, Constants.MARIO_LENGTH).getBoundsInLocal())
					&& _jumpTL.getStatus() == Status.STOPPED)	{
				_mario.setVelocity(0);
				_jumpTL.play();
			}
		}
		return false;
	}
	
	
	package Mario;

import java.util.ArrayList;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.animation.Animation.Status;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Label;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;

public class Game	{
	
	private Pane _gamespace;
	private Timeline _timeline;
	private KeyHandler _keyEvent;
	private int _score;
	private Label _scoreTxt;
	private int _lives;
	private Label _livesTxt;
	private boolean _paused;
	private Rectangle _background;
	private Mario _mario;
	private Timeline _jumpTL;
	private Timeline _moveTL;
	private Timeline _gravity;
	private ArrayList<Label> _locs;
	private ArrayList<Square> _squares;
	
	public Game(Pane gamespace, Rectangle bg)	{
		_gamespace = gamespace;
		_background = bg;
		_keyEvent = new KeyHandler();
		_gamespace.addEventHandler(KeyEvent.KEY_PRESSED, _keyEvent);
		_gamespace.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>()	{
			@Override
			public void handle(KeyEvent event) {
				KeyCode keyPressed = event.getCode();
				switch (keyPressed)	{
				case LEFT:
					_moveTL.stop();
					break;
				case RIGHT:
					_moveTL.stop();
					break;
				default:
					break;
				}
			}
		});
		this.setupGame();
		this.setupTLs();
	}
	
	private void setupGame()	{
		this.setupMap();
//		_locs = new ArrayList<Label>();
//		for (int i = 0 ; i < Constants.BLOCKS_HIGH-2 ; i++) {
//			for (int j = 0 ; j < Constants.BLOCKS_WIDE ; j++) {
//				//if (i ==  && j == )
//				Label label = new Label(Integer.toString(j + i*Constants.BLOCKS_WIDE));
//				label.setLayoutX(j*Constants.MARIO_LENGTH);
//				label.setLayoutY(i*Constants.MARIO_LENGTH);
//				_gamespace.getChildren().add(label);
//				_locs.add(label);
//				
//			}
//		}
		_mario = new Mario(_gamespace);
	}
	
	private void setupMap()	{
		Map temp = new Map();
		_squares = new ArrayList<Square>();
		Type[][] map = temp.getMap();
		Square piece = null;
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
			for (int j = 0 ; j < Constants.BLOCKS_WIDE ; j++)	{
				MapCoordinate coord = new MapCoordinate(i,j);
				switch (map[i][j])	{
				case PIT:
				case FREE:
					piece = new Free(_gamespace, coord);
					_squares.add(piece);
					break;
				case FLOOR:
					piece = new Floor(_gamespace, coord);

					_squares.add(piece);
					break;
				case BRICK:
					piece = new Brick(_gamespace, coord);

					_squares.add(piece);
					break;
				case PIPE:
					piece = new Pipe(_gamespace, coord);

					_squares.add(piece);
					break;
				case STAIR:
					piece = new Stair(_gamespace, coord);

					_squares.add(piece);
					break;
				case MYSTERY:
					piece = new Mystery(_gamespace, coord);

					_squares.add(piece);
				default:
					break;
				}
			}
		}
	}
	
	private void setupTLs()	{
		_jumpTL = new Timeline();
		_jumpTL.setCycleCount((int) (2*Constants.INIT_V/Constants.GRAVITY - Constants.DURATION));
		KeyFrame jump = new KeyFrame(Duration.seconds(Constants.DURATION), new Jump());
		_jumpTL.getKeyFrames().add(jump);
		
		_gravity = new Timeline();
		_gravity.setCycleCount(Animation.INDEFINITE);
		KeyFrame fall = new KeyFrame(Duration.seconds(Constants.DURATION), new Gravity());
		_gravity.getKeyFrames().add(fall);
		_gravity.play();
		
		
		_moveTL = new Timeline();
		_moveTL.setCycleCount(Animation.INDEFINITE);
		KeyFrame move = new KeyFrame(Duration.seconds(Constants.DURATION/3), new EventHandler<ActionEvent>()		{
			@Override
	        public void handle(ActionEvent e) {
				
				if (!checkNextBlock(_mario.getBody().getX() + _mario.getDir().distance()*Constants.DISPLACEMENT)) {
					_mario.move();
				}
					System.out.println(_mario.getBody().getX());
				if (_mario.getBody().getX() + Constants.DISPLACEMENT >= Constants.MAX_X
						&& _squares.get(_squares.size()-1).getBody().getX() + Constants.DISPLACEMENT >= Constants.GAME_WIDTH) {
					for (Square square : _squares)	{
						square.getBody().setX(square.getBody().getX() - Constants.DISPLACEMENT);
					}
				}
//				if (_mario.getBody().getX() + Constants.DISPLACEMENT >= Constants.MAX_X
//					  && _background.getX() >= Constants.GAME_WIDTH*-13.9)	{
//						_background.setX(_background.getX() - Constants.DISPLACEMENT);
//						for (Label l : _locs) {
//							l.setLayoutX(l.getLayoutX()-Constants.DISPLACEMENT);
//						}
//				}
				e.consume();
	        }
		});
		_moveTL.getKeyFrames().add(move);
	}
	
	private boolean checkNextBlock(double newX)	{
		for (Square block : _squares)	{
			if (block.getSolid() && block.getBody().intersects
					(new Rectangle(newX, _mario.getBody().getY(),
							Constants.MARIO_LENGTH, Constants.MARIO_LENGTH).getBoundsInLocal())) {
				System.out.println("intersecting");
				System.out.println(block.getType());
				return true;
			}
//			if (!block.getSolid() && block.getBody().intersects
//					(new Rectangle(newX, _mario.getBody().getY()+1,
//							Constants.MARIO_LENGTH, Constants.MARIO_LENGTH).getBoundsInLocal())
//					&& _jumpTL.getStatus() == Status.STOPPED)	{
//				_mario.setVelocity(0);
//				_jumpTL.play();
//			}
		}
		return false;
	}
	
//	public boolean hitWalkableSpace(double x, double y)	{
////		Rectangle test = new Rectangle(x,y,Constants.MARIO_LENGTH,Constants.MARIO_LENGTH);
////		for (Square block : _squares)	{
////			if (test.intersects(block.getBody().getBoundsInLocal()) && block.getSolid()) {
////				return true;
////			}
////		}
////		return false;
//		int row = (int) y%Constants.MARIO_LENGTH;
//		int col = (int) x%Constants.MARIO_LENGTH;
//		return (_squares.get(col + Constants.BLOCKS_WIDE*row).getSolid());
//	}
	
	/*private boolean inFallSpace()	{
		return (_mario.getBody().getX() >= 2020 - _background.getX() 
				&& _mario.getBody().getX() <= 2088 - Constants.MARIO_LENGTH - _background.getX());
	}*/
	
	private class KeyHandler implements EventHandler<KeyEvent>	{
		
		public KeyHandler()	{}
		
		@Override
		public void handle(KeyEvent event)	{
			KeyCode keyPressed = event.getCode();
			switch (keyPressed)	{
			case LEFT:
				_mario.setDir(Direction.LEFT);
				_moveTL.play();
				break;
			case RIGHT:
				_mario.setDir(Direction.RIGHT);
				_moveTL.play();
				break;
			case UP:
				if (_jumpTL.getStatus() == Status.STOPPED) {
					_jumpTL.stop();
					_jumpTL.play();
				}
				break;
			case DOWN:
				break;
			case P:
				if (_paused)	{
					_timeline.play();
					_paused = false;
				}
				else	{
					_timeline.pause();
					_paused = true;
				}
				break;
			case Q:
				Platform.exit();
				break;
			default:
				break;
			}
			
			event.consume();
		}
	}
	
	private class Gravity implements EventHandler<ActionEvent>	{
		
		public Gravity()	{}
		
		@Override
        public void handle(ActionEvent e) {
			if (this.checkNextBlock(_mario.getBody().getY() + Constants.DURATION*Constants.GRAVITY))	{
				_mario.getBody().setY(_mario.getBody().getY() + Constants.DURATION*Constants.GRAVITY);
			}
			e.consume();
        }
        
        private boolean checkNextBlock(double newY)	{
			for (Square block : _squares)	{
				if (block.getSolid() && block.getBody().intersects
						(new Line(_mario.getBody().getX(), newY,
								_mario.getBody().getX() + Constants.MARIO_LENGTH, newY).getBoundsInLocal())) {
					System.out.println("intersecting");
					System.out.println(block.getType());
					return true;
				}
			}
			return false;
		}
		
	}
	
	private class Jump implements EventHandler<ActionEvent>	{
		
		public Jump()	{
			_mario.setVelocity(Constants.INIT_V);
		}
		
		@Override
        public void handle(ActionEvent e) {
			_mario.updateVelocity();
			double newY = _mario.getBody().getY() + _mario.getVelocity() * Constants.DURATION;
//			if (newY > Constants.FLOOR_HEIGHT) {
//				_jumpTL.stop();
//			}
			if (this.checkNextBlock(newY + Constants.MARIO_LENGTH) && _mario.getVelocity() > 0)	{
				_mario.setVelocity(Constants.INIT_V);
				_mario.getBody().setY(_mario.getBody().getY());
				_jumpTL.stop();
			}
			else if (this.checkNextBlock(newY) && _mario.getVelocity() < 0)	{
				_mario.setVelocity(_mario.getVelocity()*-1);
				//_mario.getBody().setY(_mario.getBody().getY() + _mario.getVelocity() * Constants.DURATION);
			}
			
			else	{
				_mario.getBody().setY(newY);
			}
			e.consume();
        }
		
		private boolean checkNextBlock(double newY)	{
			for (Square block : _squares)	{
				if (block.getSolid() && block.getBody().intersects
						(new Line(_mario.getBody().getX(), newY,
								_mario.getBody().getX() + Constants.MARIO_LENGTH, newY).getBoundsInLocal())) {
					System.out.println("intersecting");
					System.out.println(block.getType());
					return true;
				}
			}
			return false;
		}
		
	}
	
}






hitWalkableSpace(_mario.getBody().getX(), _mario.getBody().getY() + newY)


package Mario;

import java.util.ArrayList;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Label;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;

public class Game	{
	
	private Pane _gamespace;
	private Timeline _timeline;
	private KeyHandler _keyEvent;
	private int _score;
	private Label _scoreTxt;
	private int _lives;
	private Label _livesTxt;
	private boolean _paused;
	private Rectangle _background;
	private Mario _mario;
	private Timeline _jumpTL;
	private Timeline _moveTL;
	private Timeline _gravity;
	private ArrayList<Label> _locs;
	private ArrayList<Square> _walkable;
	
	public Game(Pane gamespace, Rectangle bg)	{
		_gamespace = gamespace;
		_background = bg;
		_keyEvent = new KeyHandler();
		_gamespace.addEventHandler(KeyEvent.KEY_PRESSED, _keyEvent);
		_gamespace.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>()	{
			@Override
			public void handle(KeyEvent event) {
				KeyCode keyPressed = event.getCode();
				switch (keyPressed)	{
				case LEFT:
					_moveTL.stop();
					break;
				case RIGHT:
					_moveTL.stop();
					break;
				default:
					break;
				}
			}
		});
		this.setupGame();
		this.setupTLs();
	}
	
	private void setupGame()	{
		this.setupMap();
//		_locs = new ArrayList<Label>();
//		for (int i = 0 ; i < Constants.BLOCKS_HIGH-2 ; i++) {
//			for (int j = 0 ; j < Constants.BLOCKS_WIDE ; j++) {
//				//if (i ==  && j == )
//				Label label = new Label(Integer.toString(j + i*Constants.BLOCKS_WIDE));
//				label.setLayoutX(j*Constants.MARIO_LENGTH);
//				label.setLayoutY(i*Constants.MARIO_LENGTH);
//				_gamespace.getChildren().add(label);
//				_locs.add(label);
//				
//			}
//		}
		_mario = new Mario(_gamespace);
	}
	
	private void setupMap()	{
		Map temp = new Map();
		_walkable = new ArrayList<Square>();
		Type[][] map = temp.getMap();
		Square piece = null;
		for (int i = 0 ; i < Constants.BLOCKS_HIGH ; i++) {
			for (int j = 0 ; j < Constants.BLOCKS_WIDE ; j++)	{
				MapCoordinate coord = new MapCoordinate(i,j);
				//System.out.println(j + i*Constants.BLOCKS_WIDE);
				switch (map[i][j])	{
				case PIT:
				case FREE:
					piece = new Free(_gamespace, coord);
					break;
				case FLOOR:
					piece = new Floor(_gamespace, coord);
					_walkable.add(piece);
					break;
				case BRICK:
					piece = new Brick(_gamespace, coord);
					_walkable.add(piece);
					break;
				case PIPE:
					piece = new Pipe(_gamespace, coord);
					_walkable.add(piece);
					break;
				case STAIR:
					piece = new Stair(_gamespace, coord);
					_walkable.add(piece);
					break;
				case MYSTERY:
					piece = new Mystery(_gamespace, coord);
					_walkable.add(piece);
				default:
					break;
				}
			}
		}
	}
	
	private void setupTLs()	{
		_jumpTL = new Timeline();
		_jumpTL.setCycleCount(Animation.INDEFINITE);
		KeyFrame jump = new KeyFrame(Duration.seconds(Constants.DURATION), new Jump());
		_jumpTL.getKeyFrames().add(jump);
		
		/*_gravity = new Timeline();
		_gravity.setCycleCount(Animation.INDEFINITE);
		KeyFrame fall = new KeyFrame(Duration.seconds(Constants.DURATION), new Gravity());
		_gravity.getKeyFrames().add(fall);
		_gravity.play();*/
		
		
		_moveTL = new Timeline();
		_moveTL.setCycleCount(Animation.INDEFINITE);
		KeyFrame move = new KeyFrame(Duration.seconds(0.005), new EventHandler<ActionEvent>()		{
			@Override
	        public void handle(ActionEvent e) {
				
				if (!hitWalkableSpace(_mario.getBody().getX() + _mario.getDir().distance()*Constants.DISPLACEMENT, _mario.getBody().getY())) {
					_mario.move();
				}
				if (_mario.getBody().getX() + Constants.DISPLACEMENT >= Constants.MAX_X
						&& _walkable.get(_walkable.size()-1).getBody().getX() + Constants.DISPLACEMENT >= Constants.GAME_WIDTH) {
					for (Square square : _walkable)	{
						square.getBody().setX(square.getBody().getX() - Constants.DISPLACEMENT);
					}
				}
//				if (_mario.getBody().getX() + Constants.DISPLACEMENT >= Constants.MAX_X
//					  && _background.getX() >= Constants.GAME_WIDTH*-13.9)	{
//						_background.setX(_background.getX() - Constants.DISPLACEMENT);
//						for (Label l : _locs) {
//							l.setLayoutX(l.getLayoutX()-Constants.DISPLACEMENT);
//						}
//				}
				e.consume();
	        }
		});
		_moveTL.getKeyFrames().add(move);
	}
	
	public boolean hitWalkableSpace(double x, double y)	{
		Rectangle test = new Rectangle(x,y,Constants.MARIO_LENGTH,Constants.MARIO_LENGTH);
		for (Square block : _walkable)	{
			if (test.intersects(block.getBody().getBoundsInLocal())) {
				return true;
			}
		}
		return false;
	}
	
	/*private boolean inFallSpace()	{
		return (_mario.getBody().getX() >= 2020 - _background.getX() 
				&& _mario.getBody().getX() <= 2088 - Constants.MARIO_LENGTH - _background.getX());
	}*/
	
	private class KeyHandler implements EventHandler<KeyEvent>	{
		
		public KeyHandler()	{}
		
		@Override
		public void handle(KeyEvent event)	{
			KeyCode keyPressed = event.getCode();
			switch (keyPressed)	{
			case LEFT:
				_mario.setDir(Direction.LEFT);
				_moveTL.play();
				//_mario.getBody().setX(_mario.getBody().getX() - 1);
				break;
			case RIGHT:
				_mario.setDir(Direction.RIGHT);
				_moveTL.play();
				//_mario.getBody().setX(_mario.getBody().getX() + 1);
				break;
			case UP:
				if (_mario.getBody().getY() == Constants.FLOOR_HEIGHT) {
					_jumpTL.stop();
					_jumpTL.play();
				}
				break;
				//_mario.getBody().setY(_mario.getBody().getY() - 1);
			case DOWN:
				//_mario.getBody().setY(_mario.getBody().getY() + 1);
				break;
			case P:
				if (_paused)	{
					_timeline.play();
					_paused = false;
				}
				else	{
					_timeline.pause();
					_paused = true;
				}
				break;
			case Q:
				Platform.exit();
				break;
			default:
				break;
			}
			
			event.consume();
		}
	}
	
	/*private class Gravity implements EventHandler<ActionEvent>	{
		
		public Gravity()	{}
		
		@Override
        public void handle(ActionEvent e) {
			if (_mario.getBody().getY() != Constants.FLOOR_HEIGHT)	{
				_mario.getBody().setY(_mario.getBody().getY() + Constants.DURATION*Constants.GRAVITY);
			}
			e.consume();
        }
		
	}*/
	
	private class Jump implements EventHandler<ActionEvent>	{
		
		public Jump()	{
			_mario.setVelocity(Constants.INIT_V);
		}
		
		@Override
        public void handle(ActionEvent e) {
			_mario.updateVelocity();
			double newY = _mario.getBody().getY() + _mario.getVelocity() * Constants.DURATION;
			if (newY > Constants.FLOOR_HEIGHT) {
				newY = Constants.FLOOR_HEIGHT;
			}
			_mario.getBody().setY(newY);
			if (hitWalkableSpace(_mario.getBody().getX(), _mario.getBody().getY()) && _mario.getVelocity() < 0
					//_mario.getBody().getY() == Constants.FLOOR_HEIGHT
					/*&& !inFallSpace()*/)	{
				_mario.setVelocity(_mario.getVelocity()*-1);
			}
			else if (hitWalkableSpace(_mario.getBody().getX(), _mario.getBody().getY()) && _mario.getVelocity() > 0
					//_mario.getBody().getY() == Constants.FLOOR_HEIGHT
					/*&& !inFallSpace()*/)	{
				_mario.setVelocity(Constants.INIT_V);
				_jumpTL.stop();
			}
			e.consume();
        }
		
	}
	
}


 public void handle(ActionEvent e) {
				_mario.move();
				//System.out.println(_mario.getBody().getX());
				//System.out.println(_background.getX());
				if (_mario.getBody().getX() + Constants.DISPLACEMENT >= Constants.MAX_X) {
				//  && _background.getX() >= Constants.GAME_WIDTH*-13.9)	{
					_background.setX(_background.getX() - Constants.DISPLACEMENT);
					/*for (Label l : _locs) {
						l.setLayoutX(l.getLayoutX()-Constants.DISPLACEMENT);
					}*/
					//_mario.getBody().setX(_mario.getBody().getX() - 1);
				}
				e.consume();
	        }